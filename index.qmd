---
title: "Un tableau de bord du trafic aérien avec {{< fa brands r-project >}} ou {{< fa brands python >}}"
number-sections: true
filters:
   - include-code-files
---

```{=html}
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?version=1.15.25&autoLaunch=true&networking.user.enabled=true&git.repository=«https%3A%2F%2Fgithub.com%2FInseeFrLab%2Ffunathon2024_sujet2.git»&onyxia.friendlyName=«config-funathon2024»&kubernetes.role=«admin»" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/SSP%20Cloud-Ouvrir_dans_RStudio-blue?logo=rstudio&amp;logoColor=blue" alt="Onyxia"></a>
```


![](img/cockpit.png){width="25%" fig-align="center"}

# Introduction {.unnumbered}

L'objectif de ce tutoriel est d'amener, pas à pas, à la conception
voire à la mise à disposition d'un tableau de bord
du trafic aérien avec {{< fa brands r-project >}}.
Une démonstration de cette application est disponible à l'adresse <>.


L'application interactive proposée présentera un nombre de fonctionnalités
limitées afin de se concentrer sur la démarche. L'objectif est de construire
progressivement celle-ci en suivant les étapes logiques du déroulement d'un
projet de développement d'application interactive: découverte et exploration des données, création de statistiques
descriptives et de visualisations simples sur un jeu de données, 
extension du nombre de visualisations accessibles par la création d'une application. Ce tutoriel est également l'occasion de découvrir quelques
bonnes pratiques de programmation avec `R` afin de rendre les projets plus
fiables, évolutifs et lisibles. 

Les exercices de conception pas à pas de l'application s'adressent aussi bien à des
débutants qu'à des utilisateurs plus experts. La mise à disposition, c'est-à-dire
la mise en production de cette application, fait appel à des concepts
et outils plus
avancés et est donc moins accessible à des débutants.

::: callout-tip
Si vous désirez aller plus loin sur certaines dimensions de ce projet,
vous pouvez tout à fait essayer de vous-mêmes d'introduire de nouveaux
ingrédients dans l'application que vous développez.
:::




# Exploration des données de trafic aérien


## Préliminaire: récupérer le projet squelette avec `Git` {{< fa brands git-alt >}}

Si vous disposez d'un compte sur le [sspcloud](https://www.sspcloud.fr/),
la méthode recommandée pour se lancer dans ce tutoriel est de cliquer
sur le bouton suivant

```{=html}
<center>
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?version=1.15.25&autoLaunch=true&networking.user.enabled=true&git.repository=«https%3A%2F%2Fgithub.com%2FInseeFrLab%2Ffunathon2024_sujet2.git»&onyxia.friendlyName=«config-funathon2024»&kubernetes.role=«admin»" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/SSP%20Cloud-Ouvrir_dans_RStudio-blue?logo=rstudio&amp;logoColor=blue" alt="Onyxia"></a>
</center>
<br>
```



Si vous avez utilisé le lien de lancement rapide mis à disposition
sur la page [inseefrlab.github.io/funathon2024/](https://inseefrlab.github.io/funathon2024/)
ou ci-dessus, 
vous pouvez sauter l'étape de récupération du modèle de projet avec `Git`, cela
a été fait automatiquement lors de la création de votre environnement `RStudio`. 

::: {.callout-note collapse="true"}
## Récupérer le projet si vous n'avez pas utilisé le bouton proposé

:::: {.panel-tabset}
## Interface graphique

La fiche `utilitR` sur l'[utilisation de `Git`](https://book.utilitr.org/03_Fiches_thematiques/Fiche_git_utilisation.html#recuperer-url
) explicite la démarche générale pour
récupérer du code grâce à `Git`. Il est recommandé de lire celle-ci si vous
n'êtes pas familier de `Git`. 

Les étapes suivantes permettront de récupérer le projet:

1️⃣ En premier lieu, dans `RStudio`, créer un nouveau projet et sélectionner `Version Control`. 

![](https://book.utilitr.org/pics_resized/git/create_project_1.png)

2️⃣ Choisir `Git`, ce qui devrait ouvrir une fenêtre similaire à celle ci-dessous:

![](https://book.utilitr.org/pics_resized/git/create_project_2.png)

3️⃣ Dans la fenêtre `Repository URL`, passer la valeur

```r
https://github.com/inseefrlab/funathon2024_sujet2.git
```

laisser les valeurs par défaut qui viennent ensuite et créer le projet. 


## Depuis le terminal

Après avoir ouvert un terminal dans `RStudio`, faire 

```bash
git clone https://github.com/inseefrlab/funathon2024_sujet2.git
```

puis, dans l'explorateur de fichiers (fenêtre en bas à droite), cliquer
sur le fichier `RTraffic.Rproj` pour ouvrir le projet. 
::::

:::

Le projet récupéré comporte de nombreux fichiers. Nous allons 
progressivement les découvrir dans ce tutoriel. A l'heure actuelle,
on peut se concentrer sur les fichiers suivants:

```
|- renv.lock
|- global.R
|- server.R
|- ui.R
```

Le premier fichier correspond à la liste des _packages_ nécessaires
pour reproduire l'environnement. Il a été généré automatiquement grâce à 
un écosystème `renv` particulièrement adapté pour assurer la reproductibilité
de projets `R` (voir la suite). 

Les fichiers `server.R` et `ui.R` constituent le coeur de notre application 
`Shiny`. Ils représentent, respectivement, le moteur de calcul (le serveur)
et l'interface utilisateur de notre application. Le fichier `global.R` stocke
un certain nombre d'objets utiles à l'application mais qui n'ont pas besoin
d'être recalculé à chaque action sur l'interface graphique. 


## Installer les _packages_ nécessaires pour ce tutoriel

### Principe

Pour progresser dans ce tutoriel, un certain nombre de _packages_
doivent être installés. Sans eux, même avec le code de l'application, vous
ne serez pas en mesure de reproduire celle-ci. 

Les bonnes pratiques pour la gestion de 
l'environnement sont assez proches en {{< fa brands r-project >}} et {{< fa brands python >}}.
Le principal général est qu'il existe des outils qui permettent à un utilisateur de lister l'ensemble des packages dans son environnement avec leur version. Grâce à cette liste, d'autres personnes pourront reproduire l'application si elles disposent des mêmes _inputs_ (le code, les données...). 

En effet, il est important de voir l'application comme le résultat de la combinaison de plusieurs ingrédients. Dans notre cas, nous en avons trois:

* Du code `R` ou `Python` : celui-ci a été récupéré par le biais de `Git`
* Des éléments de configuration:
    + le fichier `renv.lock` (`R`) ou `requirements.txt` (`Python`) qui permettra de reconstruire notre environnement à l'identique grâce à des outils adaptés[^generation]
    + le fichier `sources.yaml` qui liste l'emplacement des sources sur le site [data.gouv](https://www.data.gouv.fr/fr/)
* Des données: nous évoquerons celles-ci lors de la prochaine partie.


![Illustration du principe de séparation du code, des données et de la configuration](./img/environment.png)

De manière générale, c'est une bonne pratique de structurer son projet comme une
combinaison de ces facteurs. Cela vous amènera à faire des projets plus reproductible
mais aussi à la structure plus lisible. 

Pour les utilisateurs de `R`, la [formation de l'Insee aux bonnes pratiques](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/)
consacre une partie aux environnements reproductibles avec `renv`. Pour les utilisateurs
de `Python`, le [cours de mise en production de projets _data science_](https://ensae-reproductibilite.github.io/website/chapters/portability.html)
consacre un chapitre au sujet. 

[^generation]: Ces fichiers ne sont pas générés manuellement. Ce sont des outils adaptés (`renv` pour `R`, `pip` pour `Python`) qui font ce travail de versionnage de l'environnement. 

### Créer l'environnement

L'intérêt d'utiliser `renv` est que recréer l'environnement nécessaire
au bon fonctionnement de l'application est très simple avec la commande:

```r
renv::restore()
```

Il est tout à fait possible, ensuite, d'installer des _packages_ supplémentaires
par le biais de `install.packages`. L'environnement proposé par notre fichier
`renv.lock` est le minimum
requis pour reproduire l'application mais ce n'est pas un environnement figé.
Si vous ajoutez des _packages_ utiles pour votre application, avant la phase de mise en production, n'oubliez pas
de faire `renv::snapshot()` pour mettre à jour le fichier `renv.lock`. 

Maintenant que nous disposons d'un environnement fonctionnel, 
nous pouvons avancer sur la conception du projet. La première étape est d'explorer
les jeux de données que nous utiliserons dans l'application

# Récupérer les données

Les sources sont listées dans le fichier `sources.yaml`. 
Notre application utilisera quatres sources différentes:

- Le trafic au niveau de chaque aéroport (format CSV)
- Le nombre de passagers pour différentes liaisons (format CSV)
- Le trafic pour différentes compagnies (format CSV)
- Les localisations des aéroports (format geojson)

## Importer la liste des sources disponibles

::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 1: lire les sources dans {{< fa brands r-project >}}

1. Le package `yaml` comporte une fonction `read_yaml` pour transformer
un fichier `YAML` en liste imbriquée. Tester cette fonction sur le fichier `sources.yml`. 

2. Transformer ce bout de code en une fonction `create_data_list`
prenant un argument `source_file` et renvoyant cette liste.

:::

<details>
<summary>
Voir la solution
</summary>
```{.r include="R/create_data_list.R"}
```


</details>

La solution est dans le fichier `R/create_data_list.R`. Elle peut être importée
dans l'environnement global grâce à la commande:

```{r}
source("R/create_data_list.R")
```

## Importer les premières bases 

```{r}
urls <- create_data_list("sources.yml")
```


::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 2: découvrir les différentes sources

Cet exercice est, en apparence, un peu long. Néanmoins la première partie
de celui-ci permet la construction d'une fonction générique d'import
des données qui permet ensuite de gagner
du temps et d'éviter la redondance de code. 

#### Données aéroports {.unnumbered}

* Comme les données sont des CSV européens (séparateur `;`),
utiliser `read_csv2` du package `readr` pour lire les données à partir 
de la liste de fichiers `unlist(urls$airports)`[^utilitr-csv].
* Il est recommandé de ne pas laisser les types par défaut des colonnes mais de figer ceux-ci avec l'argument suivant:

```{.r}
col_types = cols(
  ANMOIS = col_character(),
  APT = col_character(),
  APT_NOM = col_character(),
  APT_ZON = col_character(),
  .default = col_double()
)
```

* A partir de la variable `ANMOIS`, créer les variables `an` et `mois`.

<details>
<summary>
Aide si vous êtes bloqué sur cette question
</summary>

Pour extraire des éléments d'une chaine de caractère à partir de la position, il est recommandé d'utiliser la fonction `str_sub` du package `stringr`. Pour créer de nouvelles colonnes, il est recommandé d'utiliser la fonction `mutate` du package dplyr. 

::: {.callout-warning}
## Conseil pour se faciliter la vie ultérieurement

Il est recommandé d'utiliser `str_remove` pour retirer les zéros en début de mois
qui pourront nous créer des difficultés ultérieurement
:::

Si vous êtes toujours bloqué, la solution est donnée plus bas 👇

</details>

* Créer une fonction `clean_dataframe` qui reprend le code de création des variables `an` et `mois`, ajoute une étape de passage des noms de colonne en minuscule et renvoie le dataframe en sortie

<details>
<summary>
Solution
</summary>

```{.r include="R/clean_dataframe.R"}
```
</details>

* Créer une fonction `import_airport_data` qui prend en _input_ `list_files`
et intègre les deux étapes précédentes: la lecture des données, le nettoyage
avec `clean_dataframe`.

<details>
<summary>
Solution
</summary>

```{.r include="R/import_data.R" start-line=1 end-line=17}
```

* Reporter cette fonction dans un fichier `R/clean_dataframe.R` et faire

```{.r}
source("R/clean_dataframe.R")
```

</details>

#### Données compagnies {.unnumbered}

Sur le même principe, créer une fonction `import_compagnies_data` qui effectue
la même suite d'opérations. Faire néanmoins attention aux types des colonnes. 

```{r}
#| eval: false
#| code-fold: true
#| code-summary: "Recommandation de paramètre pour read_csv pour l'import de ces fichiers"
col_types = cols(
  ANMOIS = col_character(),
  CIE = col_character(),
  CIE_NOM = col_character(),
  CIE_NAT = col_character(),
  CIE_PAYS = col_character(),
  .default = col_double()
)
```


<details>
<summary>
Solution
</summary>

```{.r include="R/import_data.R" start-line=20 end-line=38}
```

</details>

#### Données liaisons  {.unnumbered}

Sur le même principe, créer une fonction `import_liaisons_data` qui effectue
la même suite d'opérations. Faire néanmoins attention aux types des colonnes. 

```{r}
#| eval: false
#| code-fold: true
#| code-summary: "Recommandation de paramètre pour read_csv pour l'import de ces fichiers"
col_types = cols(
  ANMOIS = col_character(),
  LSN = col_character(),
  LSN_DEP_NOM = col_character(),
  LSN_ARR_NOM = col_character(),
  LSN_SCT = col_character(),
  LSN_FSC = col_character(),
  .default = col_double()
)
```

<details>
<summary>
Solution
</summary>

```{.r include="R/import_data.R" start-line=41 end-line=60}
```

</details>

#### Localisations des aéroports {.unnumbered}

Il s'agit d'un jeu de données spatial. Pour en savoir plus sur ce type de données,
il est recommandé de consulter la [fiche  `utilitR`](https://book.utilitr.org/03_Fiches_thematiques/Fiche_donnees_spatiales.html) sur
le sujet ou [ce cours introductif](https://rgeo.linogaliana.fr/exercises/geospatial-wrangling.html) 

1. Utiliser la fonction `st_read` du package `sf` pour lire ces données (dont la localisation est stockée dans la variable `urls$geojson$aiport`). Stocker l'objet obtenu sous le nom `airports_location`
2. Vérifier que les données sont bien dans le système de représentation `WGS 84`[^crs]

<details>
<summary>
Aide
</summary>
La fonction à utiliser est `sf_crs`
</details>

3. Il est toujours utile de vérifier que nos données sont bien localisées où on les attend. Pour cela, il est pertinent de faire une carte avec un fond de carte contextuel, même si celle-ci n'est pas très soignée. Pour faire ceci, le plus simple est d'utiliser la [fonction `addMarkers`](https://rstudio.github.io/leaflet/articles/markers.html) du package `leaflet`.
Essayez de faire cette carte vous-mêmes ou consultez l'aide ci-dessous

<details>
<summary>
Code pour faire une carte `leaflet` minimale
</summary>
```{.r}
leaflet(airports_location) %>%
  addTiles() %>%
  addMarkers(popup = ~Nom)
```
</details>

Reporter toutes ces fonctions dans un fichier `R/import_data.R`. 
:::

[^utilitr-csv]: Si vous êtes peu familier avec ce type de fichiers, vous pouvez consulter la [fiche `utilitR`](https://book.utilitr.org/03_Fiches_thematiques/Fiche_import_fichiers_plats.html) sur le sujet
[^crs]: Si vous êtes peu familier avec les données géographiques, vous pouvez retenir l'idée qu'il s'agit de données traditionnelles auxquelles s'ajoute une dimension spatiale. Cette dernière vise à localiser les données sur la terre. La localisation se fait dans un espace à deux dimensions (espace cartésien) alors que notre planète est une sphère en trois dimensions. Le principe d'un système de projection est de faire ce passage en deux dimensions des positions. Le plus connu est le système GPS, qui est un héritier lointain de la représentation du monde par [Mercator](https://fr.wikipedia.org/wiki/G%C3%A9rard_Mercator). Ce système est connu sous le nom de WGS 84 et porte le code EPSG 4326. L'autre système à retenir est le Lambert 93 (code EPSG 2154) qui est la projection légale en France (celle-ci, _a contrario_ du Mercator, ne déforme pas la France sur une carte). Pour en savoir plus sur les systèmes de représentation, les avantages et inconvénients de chacun, il existe de nombreuses ressources en ligne. Des éléments introductifs, et des démonstrations interactives, en lien avec la librairie `Geopandas` de `Python` sont disponibles [ici](https://pythonds.linogaliana.fr/content/manipulation/03_geopandas_intro.html#principe). 


A l'issue de cet exercice, vous devriez avoir le fichier `R/import_data.R` suivant

<details>
<summary>
Le fichier `R/import_data.R` attendu
</summary>

```{.r include="R/import_data.R"}
```

</details>

La carte `leaflet` que vous devriez avoir obtenue à la fin de l'exercice
est la suivante:

```{r}
#| echo: false
#| output: false
library(sf)
library(leaflet)
airports_location <- st_read(urls$geojson$airport)
```

```{r}
leaflet(airports_location) %>%
  addTiles() %>%
  addMarkers(popup = ~Nom)
```

A l'issue de l'exercice, 
le code centralisé dans le script `R/import_data.R`
peut être importé via le code suivant

```{r}
source("R/import_data.R")  
```

Vous pouvez initier un script nommé `main.R` avec les lignes suivante:

```{.r include="global.R" start-line=24 end-line=34}
```

en les faisant précéder de l'import des
scripts que nous avons déjà créé dans le dossier `R`:

```r
source("R/create_data_list.R")
source("R/import_data.R")  
source("R/clean_dataframe.R")
```

Une bonne pratique est de tester son script dans une session vierge. Cela amène
à construire pas à pas une chaine plus reproductible. Pour cela, 

- Aller dans les options de `R` via `Tools > Global Options` et décocher la case `Restore .RData into workspace at setup`
- Redémarrer votre
session `R` via le menu `Session > Restart R` ou le
raccourci <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>F10</kbd>

Et exécuter votre fichier `main.R`. Vous devriez rencontrer des erreurs car nous n'avons pas géré les import de librairies dans ce script puisque notre session actuelle ne bénéficie plus des import antérieurs.

Une bonne pratique pour comprendre cette exigence de reproductibilité
est d'itérativement ajouter les librairies utiles à mesure qu'on rencontre des erreurs (notre code étant très rapide à tourner, cette logique d'essai-erreur n'est pas très coûteuse). 
Si vous ne désirez pas faire ceci (dommage, c'est un bon exercice), vous
pouvez trouver les imports de packages à faire pour que notre script soit
reproductible. 

<details>
<summary>
L'environnement minimal de reproductibilité pour que le script `main.R` fonctionne
</summary>

```{.r}
library(readr)
library(dplyr)
library(stringr)
library(sf)
``` 

</details>

Ces librairies sont à écrire au début de `main.R`. 


# Exploration des données

```{r}
#| label: intermediates-exo2
#| echo: false
#| output: false
source("intermediates/exo2.R")
```


## Le trafic par aéroport

Pour commencer, nous allons prototyper la production d'une figure
sur le trafic aérien au niveau d'un aéroport. Cela nous facilitera ensuite
l'intégration dans une application interactive. 

Pour cela, nous allons créer les deux objets temporaires suivants

```{r}
liste_aeroports <- unique(pax_apt_all$apt)
default_airport <- liste_aeroports[1]
default_airport
```

```{r}
#| output: false
#| echo: false
source("intermediates/exo3.R")
```

::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 3: graphiques de fréquentation des aéroports

1. Créer une variable `trafic` égale `apt_pax_dep + apt_pax_tr + apt_pax_arr`
2. Ne conserver que les données relatives à l'aéroport `default_airport`
3. Créer une variable `date` qui utilise les colonnes `an` et `mois`. Cette variable de date doit être au format `date`, pas au format `chr`
<details>
<summary>
Enchaînement des opérations attendues à cette étape
</summary>

```{.r include="intermediates/exo3.R" end-line=32}
```
</details>

4. Faire une figure `ggplot` toute simple pour voir la dynamique des données
afin d'obtenir une figure similaire à celle-ci

```{r}
figure_ggplot
```

Nous allons faire une application interactive par la suite. Il est donc
plus intéressant d'avoir une figure un minimum réactive pour impliquer
l'utilisateur de l'application.

5. Il est donc plus pertinent de faire une figure avec la librairie
`plotly`. Pour cela, vous pouvez vous inspirer de [cette page](https://plotly.com/r/line-charts/)

```{r}
#| echo: false
figure_plotly
```

<details>

<summary>
Le code pour générer la figure
</summary>

```{.r include="intermediates/exo3.R" start-line=15}
```

</details>

:::

Le code complet pour répliquer cet exercice est donné ci-dessous. 

<details>
<summary>
Code de l'exercice
</summary>
```{.r include="intermediates/exo3.R"}
```
</details>

Nous proposons de le transformer en fonction, ce sera plus simple à intégrer
ultérieurement dans notre application

::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 3b: une fonction de production graphique

Transformer le code ci-dessus en une fonction afin que

* les _inputs_ soient les suivants: un _dataframe_, un aéroport à sélectionner
* la sortie soit notre figure `plotly`

Tester la fonction sur d'autres aéroports de la liste. Quand vous êtes satisfaits de celle-ci, 
déplacer la définition de cette fonction dans `R/figures.R`
:::

<details>
<summary>
Fichier `R/figures.R` à l'issue de cet exercice
</summary>
```{.r include="R/figures.R" end-line="18" filename="R/figures.R"}
```
</details>

Par la suite, nous pouvons ajouter la ligne suivante à notre fichier `main.R`

```{r}
#| output: false
source("R/figures.R")
```

et utiliser cette fonction à la fin du fichier. 

<details>
<summary>
Fichier `main.R` à l'issue de cet exercice
</summary>
```{.r include="intermediates/exo3.R" filename="main.R"}
```
</details>


## Tableau HTML pour afficher des données

La première valorisation que nous intégrerons dans notre application est
le modèle de figure ci-dessus. La deuxième sera un tableau
permettant de visualiser certaines données directement dans le _dashboard_. 

Pour le prochain exercice, vous pourrez utiliser ces objets

```{r}
#| echo: true 
YEARS_LIST  <- as.character(2018:2022)
MONTHS_LIST <- 1:12
```


::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 4a: préparer les données avant de faire un beau tableau

Nous allons intégrer dans notre application deux tableaux de
statistiques descriptives.

1. Choisir un mois et une année
à partir des objets `YEARS_LIST` et `MONTHS_LIST` pour faire
un filtre sur le _dataframe_ `pax_apt_all`. Une fois
que vous êtes satisfaits, transformer cela en
fonction `create_data_from_input` prenant en argument un _dataframe_, 
une année et un mois

<details>
<summary>
Code de l'exercice
</summary>
```{.r include="R/divers_functions.R" start-line=1 end-line=6}
```
</details>


2. Pour chaque aéroport, calculer le nombre total
de passager. Rapporter cette statistique en million
de personnes. Puis classer les aérports du plus fréquenté
au moins fréquenté. Une fois que vous êtes satisfaits de
votre chaine d'opération, créer une fonction `summary_stat_airport`.

<details>
<summary>
Code de l'exercice
</summary>
```{.r include="R/divers_functions.R" start-line=8 end-line=19}
```
</details>

3. Voici une fonction pour faire le même type d'opération sur la base des
liaisons. 

<details>
<summary>
Code de l'exercice
</summary>
```{.r include="R/divers_functions.R" start-line=21}
```
</details>

Reporter les fonctions créées dans cet exercice dans un script `divers_functions.R`.
Enrichir le script `main.R` pour utiliser celles-ci en créant les _dataframes_
adéquats (correction ci-dessous)

:::

Voici une proposition de script `main.R` à l'issue de cet exercice

<details>
<summary>
Code de l'exercice
</summary>
```{.r include="intermediates/exo4a.R"}
```
</details>

Nous avons maintenant tous les ingrédients pour faire un tableau de
statistiques descriptives lisible et esthétique. Pour cela, nous allons
utiliser le _package_ [`GT`](https://gt.rstudio.com/). Avant
de créer cette table, nous allons créer une colonne supplémentaire:

```{r}
#| echo: false
#| output: false
source("intermediates/exo4a.R")
```

```{r}
stats_aeroports_table <- stats_aeroports %>%
  mutate(name_clean = paste0(str_to_sentence(apt_nom), " _(", apt, ")_")
) %>%
select(name_clean, everything())
```

Celle-ci nous permettra, une fois mise en forme, d'avoir une colonne
plus esthétique. 

::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 4b: un beau tableau (enfin !)

Les différentes questions vont permettre de construire et formatter
progressivement notre tableau. Si vous êtes bloqués, les réponses
sont ci-dessous dans des menus déroulants. 

1. En premier lieu, utiliser `GT` pour faire un tableau basique sur le _dataframe_ `stats_aeroports_table`.
N'utiliser
aucune option, celles-ci vont être progressivement ajoutées. 
2. Retirer les colonnes `apt` et	`apt_nom` de notre table. 

<details>
<summary>Il y a plusieurs
manières de faire, voici un indice sur la "meilleure"
</summary>
Il est possible d'utiliser des fonctions de sélection de colonnes
issues du _tidyverse_ dans `gt`, notamment la fonction `starts_with` (à ne pas
confondre avec celle de `stringr`)
</details>

3. Formatter les colonnes numériques (pour la sélection des colonnes numériques, voir l'indice ci-dessus). 
En consultant la documentation de `gt`, appliquer l'option qui permet de rendre plus concise la notation
des milliers (K) et millions (M). 

4. Utiliser `fmt_markdown` pour appliquer une mise en forme adaptée à la colonne `name_clean`
5. Mettre en forme les noms de colonne (`cols_labels`), le titre (`tab_header`) et la couleur de la partie supérieure du tableau (`tab_style`), les notes (`tab_source_note`) pour avoir un tableau esthéthique et informatif
6. Transformer la table en tableau interactif avec `opt_interactive`[^note-interactive]
:::

[^note-interactive]: Vous perdrez la mise en forme du _header_ du tableau qui n'est pas conciliable avec l'interactivité. 

Les réponses aux différentes questions sont données de manière successives ci-dessous.
La table finale, obtenue à l'issue de l'exercice est la suivante:

```{r}
#| code-fold: true
#| code-summary: "Réponse question 1"
#| output: false
library(gt)
table_aeroports <- gt(stats_aeroports_table)
table_aeroports
```

```{r}
#| code-fold: true
#| code-summary: "Réponse question 2"
#| output: false
table_aeroports <- table_aeroports %>%
  cols_hide(columns = starts_with("apt"))
table_aeroports
```

```{r}
#| code-fold: true
#| code-summary: "Réponse question 3"
#| output: false
table_aeroports <- table_aeroports %>%
  fmt_number(columns = starts_with("pax"), suffixing = TRUE)
table_aeroports
```


```{r}
#| code-fold: true
#| code-summary: "Réponse question 4"
#| output: false
table_aeroports <- table_aeroports %>%
  fmt_markdown(columns = "name_clean")
table_aeroports
```

```{r}
#| code-fold: true
#| code-summary: "Réponse question 5"
#| output: false
table_aeroports <- table_aeroports %>%
  cols_label(
    name_clean = md("**Aéroport**"),
    paxdep = md("**Départs**"),
    paxarr = md("**Arrivée**"),
    paxtra = md("**Transit**")
  ) %>%
  tab_header(
    title = md("**Statistiques de fréquentation**"),
    subtitle = md("Classement des aéroports")
  ) %>%
  tab_style(
    style = cell_fill(color = "powderblue"),
    locations = cells_title()
  ) %>%
  tab_source_note(source_note = md("_Source: DGAC, à partir des données sur data.gouv.fr_"))
  
table_aeroports
```

```{r}
#| code-fold: true
#| code-summary: "Réponse question 6"
table_aeroports <- table_aeroports %>%
  opt_interactive()
table_aeroports
```

  
Nous proposons de transformer ce code en fonction, cela facilitera l'utilisation
ultérieure de celui-ci dans notre application. 

::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 4c (optionnel): transformer en fonction notre chaîne `gt`

Cet exercice est optionnel. Transformer le code ci-dessus en fonction. 
Mettre à jour `main.R` pour utiliser ceci dans votre application.
:::

<details>
<summary>
Code de `R/tables.R`
</summary>
```{.r include="R/tables.R" filename="R/tables.R"}
```
</details>

<details>
<summary>
Code de `main.R`
</summary>
```{.r include="intermediates/exo4c.R" filename="main.R"}
```
</details>


## Carte des aéroports

La dernière valorisation que nous allons intégrer est une carte interactive
du trafic de nos aéroports. Cette carte va être assez basique. Si vous
désirez mettre en oeuvre des visualisations plus complexes, vous pouvez
tout à fait le faire. 

Pour cet exercice, nous allons fixer une date pour prototyper notre 
code. Cela nous facilitera la transformation ultérieure en fonction. 

```{r}
months <- 1
years <- 2019
```

Voici également une palette de couleurs qui sera utile à la fin de l'exercice. 

```{r}
palette <- c("green", "blue", "red")
```

::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 5: carte aérienne du trafic aéroportuaire

1. Créer un _dataframe_ `trafic_date` en ne conservant que les observations
de `pax_apt_all` égales à un certain mois et année (vous pouvez vous inspirer d'un `filter` fait précédemment). Utiliser celui-ci en faisant
une jointure avec `airports_location` par le biais des variables, respectivement,
`Code.OACI` et `apt`. Nommer ce _dataframe_ `trafic_aeroports`
2. A partir de l'[exemple de démarrage de `leaflet`](https://rstudio.github.io/leaflet/articles/markers.html),
créer une carte interactive qui affiche, lorsqu'on clique sur l'un des
marqueurs, le nom de l'aéroport et sa fréquentation. 
3. Créer une variable nommée `volume` qui classe chaque observation dans son [tercile](https://fr.wiktionary.org/wiki/tercile) et transforme la valeur
en couleur à partir de `palette`.  
4. A partir du code suivant et de la [fonction `addAwesomeMarkers`](https://rstudio.github.io/leaflet/articles/markers.html#awesome-icons),
reproduire une carte similaire à celle présentée plus bas. 

```r
icons <- awesomeIcons(
  icon = 'plane',
  iconColor = 'black',
  library = 'fa',
  markerColor = trafic_aeroports$color
)
```

:::: {.callout-warning collapse="true"}
## Subtilité par rapport à l'exemple de [la documentation](https://rstudio.github.io/leaflet/articles/markers.html#awesome-icons)
Par rapport à l'exemple dans [la documentation](https://rstudio.github.io/leaflet/articles/markers.html#awesome-icons),
il faut légèrement modifier le code de sorte à faire `icon=icons[]`
et non `icon = icons`.
::::
:::


```{r}
#| code-fold: true
#| code-summary: "Question 1"
trafic_date <- pax_apt_all %>%
  mutate(
    date = as.Date(paste(anmois, "01", sep=""), format = "%Y%m%d")
  ) %>%
  filter(mois %in% months, an %in% years)
trafic_aeroports <- airports_location %>%
  inner_join(trafic_date, by = c("Code.OACI" = "apt"))
```


```{r}
#| output: false
#| code-fold: true
#| code-summary: "Question 2"
library(leaflet)
  
leaflet(trafic_aeroports) %>% addTiles() %>%
  addMarkers(popup = ~paste0(Nom, ": ", trafic)) 
```

```{r}
#| code-fold: true
#| code-summary: "Question 3"
trafic_aeroports <- trafic_aeroports %>%
  mutate(
    volume = ntile(trafic, 3)
) %>%
  mutate(
    color = palette[volume]
  )
```  


```{r}
#| code-fold: true
#| code-summary: "Question 3"
icons <- awesomeIcons(
  icon = 'plane',
  iconColor = 'black',
  library = 'fa',
  markerColor = trafic_aeroports$color
)


carte_interactive <- leaflet(trafic_aeroports) %>% addTiles() %>%
  addAwesomeMarkers(
  icon=icons[],
  label=~paste0(Nom, "", " (",Code.OACI, ") : ", trafic, " voyageurs")
)
carte_interactive
```


Comme précédemment, nous proposons
de transformer la production de cette carte en fonction, cela nous permettra
d'avoir une application légère. Là encore c'est un exercice optionnel mais
intéressant à faire pour découvrir la logique de la programmation fonctionnelle. 

::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 5b (optionnel): une fonction pour notre carte

- Créer une fonction `map_leaflet_airport` avec les arguments `df`, `airports_location`
et `selected_date` produisant la carte. Insérer celle-ci dans le script `R/figures.R`
- Mettre à jour `main.R` pour utiliser cette fonction dans votre chaine. N'oubliez pas de
définir `selected_date` dans votre script. 
:::

<details>
<summary>
Code de `R/figures.R` à reprendre
</summary>
```{.r include="R/figures.R" start-line="20" filename="R/figures.R (fin du fichier)"}
```
</details>

<details>
<summary>
Code de `intermediates/exo5.R` à reprendre
</summary>
```{.r include="intermediates/exo5.R" start-line="20" filename="main.R"}
```
</details>


Appli5
Préparer un premier shiny sans plotly & leaflet

Appli6
Ajouter à l'UI le plotly & leaflet

Appli7
Contrôle de l'environnement avec renv