---
title: "Un tableau de bord du trafic aérien avec {{< fa brands r-project >}} ou {{< fa brands python >}}"
number-sections: true
filters:
   - include-code-files
---

```{=html}
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?version=1.15.25&autoLaunch=true&networking.user.enabled=true&git.repository=«https%3A%2F%2Fgithub.com%2FInseeFrLab%2Ffunathon2024_sujet2.git»&onyxia.friendlyName=«config-funathon2024»&kubernetes.role=«admin»" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/SSP%20Cloud-Ouvrir_dans_RStudio-blue?logo=rstudio&amp;logoColor=blue" alt="Onyxia"></a>
```


# Introduction

## Objectif

L'objectif de ce tutoriel est d'amener, pas à pas, à la conception
voire à la mise à disposition d'un tableau de bord (_dashboard_)
du trafic aérien avec {{< fa brands r-project >}}.
Une démonstration de cette application est disponible à l'adresse <https://rplane-dashboard.kub.sspcloud.fr/>. Ce tutoriel est également l'occasion d'apprendre quelques bonnes pratiques pour les projets {{< fa brands r-project >}} et {{< fa brands python >}}.


Afin de se concentrer sur la démarche, cette application interactive
présentera un nombre limité de fonctionnalités. L'objectif est de construire
progressivement celle-ci en suivant les étapes logiques du déroulement d'un
projet de développement d'application interactive: découverte et exploration des données, création de statistiques
descriptives et de visualisations simples sur un jeu de données, 
extension du nombre de visualisations accessibles par la création d'une application. Ce tutoriel est également l'occasion de découvrir quelques
bonnes pratiques de programmation avec {{< fa brands r-project >}}
afin de rendre les projets plus
fiables, évolutifs et lisibles. 

Les exercices de conception pas à pas de l'application s'adressent aussi bien à des
débutants qu'à des utilisateurs plus experts. La mise à disposition, c'est-à-dire
la mise en production de cette application, fait appel à des concepts
et outils plus
avancés et est donc moins accessible à des débutants.

::: callout-tip
Si vous désirez aller plus loin sur certaines dimensions de ce projet,
vous pouvez tout à fait essayer de vous-mêmes d'introduire de nouveaux
ingrédients dans l'application que vous développez.
:::


## Pourquoi faire une application interactive ?

Cette question peut apparaître naive. Pourtant, elle mérite d'être posée 
car elle permet de réfléchir à l'objectif de l'application et à son
public cible. Cette réflexion devrait être menée systématiquement car
elle guide les choix techniques ultérieurs et la répartition des tâches entre
les différents profils pouvant intervenir dans la vie du projet s'il est mis en
production (statisticien ou _data scientist_, équipes informatiques...). 

En général, on fait de la visualisation de données car les sources de données
exploitées présentent tellement de dimensions pouvant intéresser un utilisateur
qu'il est plus pertinent de le laisser explorer les données que de définir
pour lui les statistiques à mettre en avant. L'interactivité permise par les sites
web est particulièrement adaptée pour cela: le fait d'afficher ou masquer
des visualisations en fonction de choix de l'utilisateur
évite de noyer l'information par rapport à des supports figés.

Les _frameworks_ `Shiny` ({{< fa brands r-project >}}),
`Streamlit` ou `Dash` ({{< fa brands python >}}) permettent de rapidement
mettre en oeuvre ce type de site web. Pour une phase de construction
d'un prototype, c'est un choix technique intéressant qui peut provoquer l'effet
_wahou_ attendu pour lancer le projet à plus grande échelle. En effet, ces solutions
techniques permettent, avec les outils bien connus des praticiens de la donnée, {{< fa brands r-project >}} ou {{< fa brands python >}} principalement, de créer rapidement un site web fonctionnel, ergonomique et effectuant des opérations en fonction d'actions de l'utilisateur
sur la page web. Tout ceci sans avoir à maîtriser des notions complexes de
développement web. 

Néanmoins, passée cette phase d'expérimentation,
le partage
de ces applications, au-delà d'un partage d'écran pour des démonstrations,
est moins évident. C'est parce que la connaissance de ces notions complexes qui permettent le bon fonctionnement d'un site web et dont la maîtrise n'est pas nécessaire lorsqu'on se lance dans la construction du site deviennent utiles passée la phase d'expérimentation. 
Celles-ci dépassent néanmoins le champ de compétence
des statisticiens ou _data scientists_. 

Autrement dit, si le projet a l'ambition d'être partagé
à une audience large qui n'a pas les compétences techniques pour faire tourner elle-même
le code, il convient de prendre en compte le fait qu'il faudra dans l'équipe projet
des compétences de développement web. Si le projet est expérimental, c'est moins un problème: `Shiny`, `Dash` ou `Streamlit` permettront d'avoir rapidement un prototype viable. 

Il existe heureusement des solutions techniques plus simples à mettre en oeuvre que `Shiny`,
`Streamlit` ou `Dash`. Les sites web statiques font partie de cet
éventail des possibles et représentent souvent une alternative pertinente aux applications interactives à condition qu'ils soient bien pensés. 
Ils sont notamment pertinents pour les applications de visualisation
de données où cette dernière est déjà préparée en amont. Avoir un serveur `R` ou `Python`
se justifie en effet si des étapes complexes de structuration de données interviennent. Néanmoins, si celles-ci ne sont pas nécessaires, un
simple enrobage avec un constructeur de site comme `Quarto` peut suffire, à condition
que
les productions graphiques ne soient pas trop complexes à créer. Pour des sites faisant intervenir des interactions complexes entre actions d'un utilisateur (bouton, menu déroulant, etc. ) et
affichage, il faudra recourir à du  `Javascript` (technologie utilisée par les sites spécialisés dans la _dataviz_), ce qui fait, à nouveau, appel à des compétences qui dépassent celles des _data scientists_ ou statisticiens classiques. 

En résumé, les éléments ci-dessus ont vocation à servir de mise en garde. `Shiny`, `Dash` ou `Streamlit` sont d'excellents outils techniques lorsqu'ils sont utilisés à bon escient. Néanmoins, leur simplicité d'usage ne doit pas amener à oublier de se poser des questions vitales comme celui du cycle de vie du projet, du public cible ou encore de la compétence des équipes amenées à le maintenir s'il perdure au-delà d'une phase d'expérimentation.

::: {.callout-warning collapse="true"}
## Site statique vs application réactive

La solution que nous allons proposer 
pour les sites statiques, `Quarto` associé
à `Github Pages`, peut être utilisée dans le cadre des parcours 
_"rapport reproductible"_ ou _"dashboard / application interactive"_. 

La distinction principale entre ces deux approches est qu'elles
s'appuient sur des serveurs différents. Un site statique repose
sur un serveur web là où `Streamlit` s'appuie sur 
serveur classique en _backend_. La différence principale
entre ces deux types de serveurs
réside principalement dans leur fonction et leur utilisation:

- Un __serveur web__ est spécifiquement conçu pour stocker, traiter et livrer des pages web aux clients. Cela inclut des fichiers HTML, CSS, JavaScript, images, etc. Les serveurs web écoutent les requêtes HTTP/HTTPS provenant des navigateurs des utilisateurs et y répondent en envoyant les données demandées.
- Un **serveur _backend_** classique est conçu pour effectuer des opérations en réponse à un _front_, en l'occurrence une page web. 
Dans le contexte d'une application `Streamlit` (resp. `Shiny`), il s'agit d'un serveur avec l'environnement `Python` (resp. `R`) _ad hoc_ pour
exécuter le code nécessaire à répondre à toute action d'un utilisateur de l'application. 

:::



# Exploration des données de trafic aérien

TO DO: expliquer la démarche

## Préliminaire: récupérer le projet squelette avec `Git` {{< fa brands git-alt >}}

Si vous disposez d'un compte sur le [sspcloud](https://www.sspcloud.fr/),
la méthode recommandée pour se lancer dans ce tutoriel est de cliquer
sur le bouton suivant

```{=html}
<center>
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?version=1.15.25&autoLaunch=true&networking.user.enabled=true&git.repository=«https%3A%2F%2Fgithub.com%2FInseeFrLab%2Ffunathon2024_sujet2.git»&onyxia.friendlyName=«config-funathon2024»&kubernetes.role=«admin»" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/SSP%20Cloud-Ouvrir_dans_RStudio-blue?logo=rstudio&amp;logoColor=blue" alt="Onyxia"></a>
</center>
<br>
```



Si vous avez utilisé le lien de lancement rapide mis à disposition
sur la page [inseefrlab.github.io/funathon2024/](https://inseefrlab.github.io/funathon2024/)
ou ci-dessus ☝️, 
vous pouvez sauter l'étape de récupération du modèle de projet avec `Git` {{< fa brands git-alt >}}, cela
a été fait automatiquement lors de la création de votre environnement `RStudio`. 
Cela ne vous dispense d'ailleurs pas de faire du `Git` tout au long du tutoriel,
c'est une bonne pratique, même sur
des projets ponctuels ou vous êtes seuls à travailler. 

::: {.callout-note collapse="true"}
## Récupérer le projet si vous n'avez pas utilisé le bouton proposé

:::: {.panel-tabset}
## Interface graphique

La fiche `utilitR` sur l'[utilisation de `Git`](https://book.utilitr.org/03_Fiches_thematiques/Fiche_git_utilisation.html#recuperer-url
) explicite la démarche générale pour
récupérer du code grâce à `Git`. Il est recommandé de lire celle-ci si vous
n'êtes pas familier de `Git`. 

Les étapes suivantes permettront de récupérer le projet:

1️⃣ En premier lieu, dans `RStudio`, créer un nouveau projet et sélectionner `Version Control`. 

![](https://book.utilitr.org/pics_resized/git/create_project_1.png)

2️⃣ Choisir `Git`, ce qui devrait ouvrir une fenêtre similaire à celle ci-dessous:

![](https://book.utilitr.org/pics_resized/git/create_project_2.png)

3️⃣ Dans la fenêtre `Repository URL`, passer la valeur

```r
https://github.com/inseefrlab/funathon2024_sujet2.git
```

laisser les valeurs par défaut qui viennent ensuite et créer le projet. 


## Depuis le terminal

Après avoir ouvert un terminal dans `RStudio`, faire 

```bash
git clone https://github.com/inseefrlab/funathon2024_sujet2.git
```

puis, dans l'explorateur de fichiers (fenêtre en bas à droite), cliquer
sur le fichier `RTraffic.Rproj` pour ouvrir le projet. 
::::

:::

Le projet récupéré comporte de nombreux fichiers. Nous allons 
progressivement les découvrir dans ce tutoriel. A l'heure actuelle,
on peut se concentrer sur les fichiers suivants:

```
|- renv.lock
|- global.R
|- server.R
|- ui.R
```

Le premier fichier correspond à la liste des _packages_ nécessaires
pour reproduire l'environnement. Il a été généré automatiquement grâce à 
un écosystème `renv` particulièrement adapté pour assurer la reproductibilité
de projets `R` (voir la suite). 

Les fichiers `server.R` et `ui.R` constituent le coeur de notre application 
`Shiny`. Ils représentent, respectivement, le moteur de calcul (le serveur)
et l'interface utilisateur de notre application. Le fichier `global.R` stocke
un certain nombre d'objets utiles à l'application mais qui n'ont pas besoin
d'être recalculé à chaque action sur l'interface graphique. Nous allons progressivement construire ces fichiers pendant les différents exercices.


## Installer les _packages_ nécessaires pour ce tutoriel

### Principe

Pour progresser dans ce tutoriel, un certain nombre de _packages_
doivent être installés. Sans eux, même avec le code de l'application, vous
ne serez pas en mesure de reproduire celle-ci. 

Les bonnes pratiques pour la gestion de 
l'environnement sont assez proches en {{< fa brands r-project >}} et {{< fa brands python >}}.
Le principal général est qu'il existe des outils qui permettent à un utilisateur de lister l'ensemble des packages dans son environnement avec leur version. Grâce à cette liste, d'autres personnes pourront reproduire l'application si elles disposent des mêmes _inputs_ (le code, les données...). 

En effet, il est important de voir l'application comme le résultat de la combinaison de plusieurs ingrédients. Dans notre cas, nous en avons trois:

* Du code `R` ou `Python` : celui-ci a été récupéré par le biais de `Git`
* Des éléments de configuration:
    + le fichier `renv.lock` (`R`) ou `requirements.txt` (`Python`) qui permettra de reconstruire notre environnement à l'identique grâce à des outils adaptés[^generation]
    + le fichier `sources.yaml` qui liste l'emplacement des sources sur le site [data.gouv](https://www.data.gouv.fr/fr/)
* Des données: nous évoquerons celles-ci lors de la prochaine partie.


![Illustration du principe de séparation du code, des données et de la configuration](./img/environment.png)

De manière générale, c'est une bonne pratique de structurer son projet comme une
combinaison de ces facteurs. Cela vous amènera à faire des projets plus reproductible
mais aussi à la structure plus lisible. 

Pour les utilisateurs de `R`, la [formation de l'Insee aux bonnes pratiques](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/)
consacre une partie aux environnements reproductibles avec `renv`. Pour les utilisateurs
de `Python`, le [cours de mise en production de projets _data science_](https://ensae-reproductibilite.github.io/website/chapters/portability.html)
consacre un chapitre au sujet. 

[^generation]: Ces fichiers ne sont pas générés manuellement. Ce sont des outils adaptés (`renv` pour `R`, `pip` pour `Python`) qui font ce travail de versionnage de l'environnement. 

### Créer l'environnement

Si vous avez déjà tenté de partager un code qui fonctionnait chez vous,
il est presque certain que la personne ayant voulu le réutiliser a rencontré
une erreur si elle a tenté de le faire tourner. C'est tout à fait normal car
vous avez distribué votre code, éventuellement vos données, mais pas le troisième
pilier de l'image précédente, à savoir la configuration de l'environnement dans lequel votre code fonctionnait. La solution la plus fiable, mais peu pratique, serait de donner votre ordinateur à la personne qui tente de réutiliser votre code. En livrant votre ordinateur, vous fournissez votre environnement de travail mais également beaucoup d'éléments supplémentaires qui ne sont pas indispensables à l'application.

Une solution plus simple est de fournir les spécifications qui ont permis à votre
code de fonctionner. Dans un monde idéal, il s'agit de fournir la liste
des _packages_ et leur version. Si la personne à qui vous partagez votre code et vos données a cette même liste de versions de _packages_, et pas de _packages_ supplémentaires venant polluer l'environnement, les chances d'avoir la même application que vous sont très élevées. 

`renv` est un gestionnaire de _packages_ qui permet de faire ces deux opérations:

1. Enregistrer la liste de _packages_ après avoir fait tourné un code
2. Restaurer l'environnement à partir de cette liste

En l'occurrence, pour vous, l'important est le second point: pouvoir recréer l'environnement nécessaire
au bon fonctionnement de l'application. Ceci est très simple grâce à la commande

```r
renv::restore()
```

Cette commande doit être lancée depuis la console `R` ouverte dans le projet qui
a été récupéré. L'environnement créé n'est pas figé. 
Il est tout à fait possible, ensuite, d'installer des _packages_ supplémentaires
par le biais de `install.packages`. L'environnement proposé par notre fichier
`renv.lock` est le minimum
requis pour reproduire l'application mais ce n'est pas un environnement figé.
Si vous ajoutez des _packages_ utiles pour votre application, avant la phase de mise en production, n'oubliez pas
de faire `renv::snapshot()` pour mettre à jour le fichier `renv.lock` (c'est le point 1. évoqué précédemment). 


::: {.callout-warning collapse="true"}
## Ce que `renv` évite

On retrouve parfois sur internet un code similaire à celui-ci :

```r
# A ne pas reproduire chez vous 😨
if (!requireNamespace("dplyr", quietly = TRUE)) {
  install.packages("dplyr")
}
```

C'est une gestion artisanale de l'environnement qui n'est pas conseillée. `renv` sera plus simple et
plus fiable.

:::

Maintenant que nous disposons d'un environnement fonctionnel, 
nous pouvons avancer sur la conception du projet. La première étape est d'explorer
les jeux de données que nous utiliserons dans l'application.

# Récupérer les données

Les sources sont listées dans le fichier `sources.yaml`. 
Notre application utilisera quatres sources différentes:

- Le trafic au niveau de chaque aéroport (format CSV)
- Le nombre de passagers pour différentes liaisons (format CSV)
- Le trafic pour différentes compagnies (format CSV)
- Les localisations des aéroports (format geojson)

Une bonne pratique, lorsqu'on utilise plusieurs sources,
est de lister celles-ci dans un fichier `YAML` plutôt que de les inscrire
en brut dans le code. Ce dernier sera plus lisible grâce à cette approche.

<details>
<summary>

Voir le fichier `sources.yml`

</summary>
```{.yaml include="sources.yml" filename="sources.yml"}
```
</details>


## Importer la liste des sources disponibles


::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 1: lire les sources dans {{< fa brands r-project >}}

1. Le package `yaml` comporte une fonction `read_yaml` pour transformer
un fichier `YAML` en liste imbriquée. Tester cette fonction sur le fichier `sources.yml`. 

2. Transformer ce bout de code en une fonction `create_data_list`
prenant un argument `source_file` et renvoyant cette liste.

:::

<details>
<summary>
Voir la solution à cet exercice
</summary>
```{.r include="R/create_data_list.R"}
```


</details>

La solution est dans le fichier `R/create_data_list.R`. Elle peut être importée
dans l'environnement global grâce à la commande:

```{r}
source("R/create_data_list.R")
```

## Importer les premières bases 

```{r}
urls <- create_data_list("sources.yml")
```


::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 2: découvrir les différentes sources

Cet exercice est, en apparence, un peu long. Néanmoins la première partie
de celui-ci permet la construction d'une fonction générique d'import
des données qui permet ensuite de gagner
du temps et d'éviter la redondance de code. 

#### Données aéroports {.unnumbered}

* Comme les données sont des CSV européens (séparateur `;`),
utiliser `read_csv2` du package `readr` pour lire les données à partir 
de la liste de fichiers `unlist(urls$airports)`[^utilitr-csv].
* Il est recommandé de ne pas laisser les types par défaut des colonnes mais de figer ceux-ci avec l'argument suivant:

```{.r}
col_types = cols(
  ANMOIS = col_character(),
  APT = col_character(),
  APT_NOM = col_character(),
  APT_ZON = col_character(),
  .default = col_double()
)
```

* A partir de la variable `ANMOIS`, créer les variables `an` et `mois`.

<details>
<summary>
Aide si vous êtes bloqué sur cette question
</summary>

Pour extraire des éléments d'une chaine de caractère à partir de la position, il est recommandé d'utiliser la fonction `str_sub` du package `stringr`. Pour créer de nouvelles colonnes, il est recommandé d'utiliser la fonction `mutate` du package dplyr. 

::: {.callout-warning}
## Conseil pour se faciliter la vie ultérieurement

Il est recommandé d'utiliser `str_remove` pour retirer les zéros en début de mois
qui pourront nous créer des difficultés ultérieurement
:::

Si vous êtes toujours bloqué, la solution est donnée plus bas 👇

</details>

* Créer une fonction `clean_dataframe` qui reprend le code de création des variables `an` et `mois`, ajoute une étape de passage des noms de colonne en minuscule et renvoie le dataframe en sortie

<details>
<summary>
Solution
</summary>

```{.r include="R/clean_dataframe.R"}
```
</details>

* Créer une fonction `import_airport_data` qui prend en _input_ `list_files`
et intègre les deux étapes précédentes: la lecture des données, le nettoyage
avec `clean_dataframe`.

<details>
<summary>
Solution
</summary>

```{.r include="R/import_data.R" start-line=1 end-line=17}
```

* Reporter cette fonction dans un fichier `R/clean_dataframe.R` et faire

```{.r}
source("R/clean_dataframe.R")
```

</details>

#### Données compagnies {.unnumbered}

Sur le même principe, créer une fonction `import_compagnies_data` qui effectue
la même suite d'opérations. Faire néanmoins attention aux types des colonnes. 

```{r}
#| eval: false
#| code-fold: true
#| code-summary: "Recommandation de paramètre pour read_csv pour l'import de ces fichiers"
col_types = cols(
  ANMOIS = col_character(),
  CIE = col_character(),
  CIE_NOM = col_character(),
  CIE_NAT = col_character(),
  CIE_PAYS = col_character(),
  .default = col_double()
)
```


<details>
<summary>
Solution
</summary>

```{.r include="R/import_data.R" start-line=20 end-line=38}
```

</details>

#### Données liaisons  {.unnumbered}

Sur le même principe, créer une fonction `import_liaisons_data` qui effectue
la même suite d'opérations. Faire néanmoins attention aux types des colonnes. 

```{r}
#| eval: false
#| code-fold: true
#| code-summary: "Recommandation de paramètre pour read_csv pour l'import de ces fichiers"
col_types = cols(
  ANMOIS = col_character(),
  LSN = col_character(),
  LSN_DEP_NOM = col_character(),
  LSN_ARR_NOM = col_character(),
  LSN_SCT = col_character(),
  LSN_FSC = col_character(),
  .default = col_double()
)
```

<details>
<summary>
Solution
</summary>

```{.r include="R/import_data.R" start-line=41 end-line=60}
```

</details>

#### Localisations des aéroports {.unnumbered}

Il s'agit d'un jeu de données spatial. Pour en savoir plus sur ce type de données,
il est recommandé de consulter la [fiche  `utilitR`](https://book.utilitr.org/03_Fiches_thematiques/Fiche_donnees_spatiales.html) sur
le sujet ou [ce cours introductif](https://rgeo.linogaliana.fr/exercises/geospatial-wrangling.html) 

1. Utiliser la fonction `st_read` du package `sf` pour lire ces données (dont la localisation est stockée dans la variable `urls$geojson$aiport`). Stocker l'objet obtenu sous le nom `airports_location`
2. Vérifier que les données sont bien dans le système de représentation `WGS 84`[^crs]

<details>
<summary>
Aide
</summary>
La fonction à utiliser est `sf_crs`
</details>

3. Il est toujours utile de vérifier que nos données sont bien localisées où on les attend. Pour cela, il est pertinent de faire une carte avec un fond de carte contextuel, même si celle-ci n'est pas très soignée. Pour faire ceci, le plus simple est d'utiliser la [fonction `addMarkers`](https://rstudio.github.io/leaflet/articles/markers.html) du package `leaflet`.
Essayez de faire cette carte vous-mêmes ou consultez l'aide ci-dessous

<details>
<summary>
Code pour faire une carte `leaflet` minimale
</summary>
```{.r}
leaflet(airports_location) %>%
  addTiles() %>%
  addMarkers(popup = ~Nom)
```
</details>

Reporter toutes ces fonctions dans un fichier `R/import_data.R`. 
:::

[^utilitr-csv]: Si vous êtes peu familier avec ce type de fichiers, vous pouvez consulter la [fiche `utilitR`](https://book.utilitr.org/03_Fiches_thematiques/Fiche_import_fichiers_plats.html) sur le sujet
[^crs]: Si vous êtes peu familier avec les données géographiques, vous pouvez retenir l'idée qu'il s'agit de données traditionnelles auxquelles s'ajoute une dimension spatiale. Cette dernière vise à localiser les données sur la terre. La localisation se fait dans un espace à deux dimensions (espace cartésien) alors que notre planète est une sphère en trois dimensions. Le principe d'un système de projection est de faire ce passage en deux dimensions des positions. Le plus connu est le système GPS, qui est un héritier lointain de la représentation du monde par [Mercator](https://fr.wikipedia.org/wiki/G%C3%A9rard_Mercator). Ce système est connu sous le nom de WGS 84 et porte le code EPSG 4326. L'autre système à retenir est le Lambert 93 (code EPSG 2154) qui est la projection légale en France (celle-ci, _a contrario_ du Mercator, ne déforme pas la France sur une carte). Pour en savoir plus sur les systèmes de représentation, les avantages et inconvénients de chacun, il existe de nombreuses ressources en ligne. Des éléments introductifs, et des démonstrations interactives, en lien avec la librairie `Geopandas` de `Python` sont disponibles [ici](https://pythonds.linogaliana.fr/content/manipulation/03_geopandas_intro.html#principe). 


A l'issue de cet exercice, vous devriez avoir le fichier `R/import_data.R` suivant

<details>
<summary>
Le fichier `R/import_data.R` attendu
</summary>

```{.r include="R/import_data.R"}
```

</details>

La carte `leaflet` que vous devriez avoir obtenue à la fin de l'exercice
est la suivante:

```{r}
#| echo: false
#| output: false
library(sf)
library(leaflet)
airports_location <- st_read(urls$geojson$airport)
```

```{r}
leaflet(airports_location) %>%
  addTiles() %>%
  addMarkers(popup = ~Nom)
```

A l'issue de l'exercice, 
le code centralisé dans le script `R/import_data.R`
peut être importé via le code suivant

```{r}
source("R/import_data.R")  
```

Vous pouvez initier un script nommé `main.R` avec les lignes suivante:

```{.r include="global.R" start-line=24 end-line=34}
```

en les faisant précéder de l'import des
scripts que nous avons déjà créé dans le dossier `R`:

```r
source("R/create_data_list.R")
source("R/import_data.R")  
source("R/clean_dataframe.R")
```

Une bonne pratique est de tester son script dans une session vierge. Cela amène
à construire pas à pas une chaine plus reproductible. Pour cela, 

- Aller dans les options de `R` via `Tools > Global Options` et décocher la case `Restore .RData into workspace at setup`
- Redémarrer votre
session `R` via le menu `Session > Restart R` ou le
raccourci <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>F10</kbd>

Et exécuter votre fichier `main.R`. Vous devriez rencontrer des erreurs car nous n'avons pas géré les import de librairies dans ce script puisque notre session actuelle ne bénéficie plus des import antérieurs.

Une bonne pratique pour comprendre cette exigence de reproductibilité
est d'itérativement ajouter les librairies utiles à mesure qu'on rencontre des erreurs (notre code étant très rapide à tourner, cette logique d'essai-erreur n'est pas très coûteuse). 
Si vous ne désirez pas faire ceci (dommage, c'est un bon exercice), vous
pouvez trouver les imports de packages à faire pour que notre script soit
reproductible. 

<details>
<summary>
L'environnement minimal de reproductibilité pour que le script `main.R` fonctionne
</summary>

```{.r}
library(readr)
library(dplyr)
library(stringr)
library(sf)
``` 

</details>

Ces librairies sont à écrire au début de `main.R`. 


# Exploration des données

```{r}
#| label: intermediates-exo2
#| echo: false
#| output: false
source("intermediates/exo2.R")
```


## Le trafic par aéroport

Pour commencer, nous allons prototyper la production d'une figure
sur le trafic aérien au niveau d'un aéroport. Cela nous facilitera ensuite
l'intégration dans une application interactive. 

Pour cela, nous allons créer les deux objets temporaires suivants

```{r}
liste_aeroports <- unique(pax_apt_all$apt)
default_airport <- liste_aeroports[1]
default_airport
```

```{r}
#| output: false
#| echo: false
source("intermediates/exo3.R")
```

::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 3: graphiques de fréquentation des aéroports

1. Créer une variable `trafic` égale `apt_pax_dep + apt_pax_tr + apt_pax_arr`
2. Ne conserver que les données relatives à l'aéroport `default_airport`
3. Créer une variable `date` qui utilise les colonnes `an` et `mois`. Cette variable de date doit être au format `date`, pas au format `chr`
<details>
<summary>
Enchaînement des opérations attendues à cette étape
</summary>

```{.r include="intermediates/exo3.R" end-line=32}
```
</details>

4. Faire une figure `ggplot` toute simple pour voir la dynamique des données
afin d'obtenir une figure similaire à celle-ci

```{r}
figure_ggplot
```

Nous allons faire une application interactive par la suite. Il est donc
plus intéressant d'avoir une figure un minimum réactive pour impliquer
l'utilisateur de l'application.

5. Il est donc plus pertinent de faire une figure avec la librairie
`plotly`. Pour cela, vous pouvez vous inspirer de [cette page](https://plotly.com/r/line-charts/)

```{r}
#| echo: false
figure_plotly
```

<details>

<summary>
Le code pour générer la figure
</summary>

```{.r include="intermediates/exo3.R" start-line=15}
```

</details>

:::

Le code complet pour répliquer cet exercice est donné ci-dessous. 

<details>
<summary>
Code de l'exercice
</summary>
```{.r include="intermediates/exo3.R"}
```
</details>

Nous proposons de le transformer en fonction, ce sera plus simple à intégrer
ultérieurement dans notre application

::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 3b: une fonction de production graphique

Transformer le code ci-dessus en une fonction afin que

* les _inputs_ soient les suivants: un _dataframe_, un aéroport à sélectionner
* la sortie soit notre figure `plotly`

Tester la fonction sur d'autres aéroports de la liste. Quand vous êtes satisfaits de celle-ci, 
déplacer la définition de cette fonction dans `R/figures.R`
:::

<details>
<summary>
Fichier `R/figures.R` à l'issue de cet exercice
</summary>
```{.r include="R/figures.R" end-line="18" filename="R/figures.R"}
```
</details>

Par la suite, nous pouvons ajouter la ligne suivante à notre fichier `main.R`

```{r}
#| output: false
source("R/figures.R")
```

et utiliser cette fonction à la fin du fichier. 

<details>
<summary>
Fichier `main.R` à l'issue de cet exercice
</summary>
```{.r include="intermediates/exo3.R" filename="main.R"}
```
</details>


## Tableau HTML pour afficher des données

La première valorisation que nous intégrerons dans notre application est
le modèle de figure ci-dessus. La deuxième sera un tableau
permettant de visualiser certaines données directement dans le _dashboard_. 

Pour le prochain exercice, vous pourrez utiliser ces objets

```{r}
#| echo: true 
YEARS_LIST  <- as.character(2018:2022)
MONTHS_LIST <- 1:12
```


::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 4a: préparer les données avant de faire un beau tableau

Nous allons intégrer dans notre application deux tableaux de
statistiques descriptives.

1. Choisir un mois et une année
à partir des objets `YEARS_LIST` et `MONTHS_LIST` pour faire
un filtre sur le _dataframe_ `pax_apt_all`. Une fois
que vous êtes satisfaits, transformer cela en
fonction `create_data_from_input` prenant en argument un _dataframe_, 
une année et un mois

<details>
<summary>
Code de l'exercice
</summary>
```{.r include="R/divers_functions.R" start-line=1 end-line=6}
```
</details>


2. Pour chaque aéroport, calculer le nombre total
de passager. Rapporter cette statistique en million
de personnes. Puis classer les aérports du plus fréquenté
au moins fréquenté. Une fois que vous êtes satisfaits de
votre chaine d'opération, créer une fonction `summary_stat_airport`.

<details>
<summary>
Code de l'exercice
</summary>
```{.r include="R/divers_functions.R" start-line=8 end-line=19}
```
</details>

3. Voici une fonction pour faire le même type d'opération sur la base des
liaisons. 

<details>
<summary>
Code de l'exercice
</summary>
```{.r include="R/divers_functions.R" start-line=21}
```
</details>

Reporter les fonctions créées dans cet exercice dans un script `divers_functions.R`.
Enrichir le script `main.R` pour utiliser celles-ci en créant les _dataframes_
adéquats (correction ci-dessous)

:::

Voici une proposition de script `main.R` à l'issue de cet exercice

<details>
<summary>
Code de l'exercice
</summary>
```{.r include="intermediates/exo4a.R"}
```
</details>

Nous avons maintenant tous les ingrédients pour faire un tableau de
statistiques descriptives lisible et esthétique. Pour cela, nous allons
utiliser le _package_ [`GT`](https://gt.rstudio.com/). Avant
de créer cette table, nous allons créer une colonne supplémentaire:

```{r}
#| echo: false
#| output: false
source("intermediates/exo4a.R")
```

```{r}
stats_aeroports_table <- stats_aeroports %>%
  mutate(name_clean = paste0(str_to_sentence(apt_nom), " _(", apt, ")_")
) %>%
select(name_clean, everything())
```

Celle-ci nous permettra, une fois mise en forme, d'avoir une colonne
plus esthétique. 

::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 4b: un beau tableau (enfin !)

Les différentes questions vont permettre de construire et formatter
progressivement notre tableau. Si vous êtes bloqués, les réponses
sont ci-dessous dans des menus déroulants. 

1. En premier lieu, utiliser `GT` pour faire un tableau basique sur le _dataframe_ `stats_aeroports_table`.
N'utiliser
aucune option, celles-ci vont être progressivement ajoutées. 
2. Retirer les colonnes `apt` et	`apt_nom` de notre table. 

<details>
<summary>Il y a plusieurs
manières de faire, voici un indice sur la "meilleure"
</summary>
Il est possible d'utiliser des fonctions de sélection de colonnes
issues du _tidyverse_ dans `gt`, notamment la fonction `starts_with` (à ne pas
confondre avec celle de `stringr`)
</details>

3. Formatter les colonnes numériques (pour la sélection des colonnes numériques, voir l'indice ci-dessus). 
En consultant la documentation de `gt`, appliquer l'option qui permet de rendre plus concise la notation
des milliers (K) et millions (M). 

4. Utiliser `fmt_markdown` pour appliquer une mise en forme adaptée à la colonne `name_clean`
5. Mettre en forme les noms de colonne (`cols_labels`), le titre (`tab_header`) et la couleur de la partie supérieure du tableau (`tab_style`), les notes (`tab_source_note`) pour avoir un tableau esthéthique et informatif
6. Transformer la table en tableau interactif avec `opt_interactive`[^note-interactive]
:::

[^note-interactive]: Vous perdrez la mise en forme du _header_ du tableau qui n'est pas conciliable avec l'interactivité. 

Les réponses aux différentes questions sont données de manière successives ci-dessous.
La table finale, obtenue à l'issue de l'exercice est la suivante:

```{r}
#| code-fold: true
#| code-summary: "Réponse question 1"
#| output: false
library(gt)
table_aeroports <- gt(stats_aeroports_table)
table_aeroports
```

```{r}
#| code-fold: true
#| code-summary: "Réponse question 2"
#| output: false
table_aeroports <- table_aeroports %>%
  cols_hide(columns = starts_with("apt"))
table_aeroports
```

```{r}
#| code-fold: true
#| code-summary: "Réponse question 3"
#| output: false
table_aeroports <- table_aeroports %>%
  fmt_number(columns = starts_with("pax"), suffixing = TRUE)
table_aeroports
```


```{r}
#| code-fold: true
#| code-summary: "Réponse question 4"
#| output: false
table_aeroports <- table_aeroports %>%
  fmt_markdown(columns = "name_clean")
table_aeroports
```

```{r}
#| code-fold: true
#| code-summary: "Réponse question 5"
#| output: false
table_aeroports <- table_aeroports %>%
  cols_label(
    name_clean = md("**Aéroport**"),
    paxdep = md("**Départs**"),
    paxarr = md("**Arrivée**"),
    paxtra = md("**Transit**")
  ) %>%
  tab_header(
    title = md("**Statistiques de fréquentation**"),
    subtitle = md("Classement des aéroports")
  ) %>%
  tab_style(
    style = cell_fill(color = "powderblue"),
    locations = cells_title()
  ) %>%
  tab_source_note(source_note = md("_Source: DGAC, à partir des données sur data.gouv.fr_"))
  
table_aeroports
```

```{r}
#| code-fold: true
#| code-summary: "Réponse question 6"
table_aeroports <- table_aeroports %>%
  opt_interactive()
table_aeroports
```

  
Nous proposons de transformer ce code en fonction, cela facilitera l'utilisation
ultérieure de celui-ci dans notre application. 

::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 4c (optionnel): transformer en fonction notre chaîne `gt`

Cet exercice est optionnel. Transformer le code ci-dessus en fonction. 
Mettre à jour `main.R` pour utiliser ceci dans votre application.
:::

<details>
<summary>
Code de `R/tables.R`
</summary>
```{.r include="R/tables.R" filename="R/tables.R"}
```
</details>

<details>
<summary>
Code de `main.R`
</summary>
```{.r include="intermediates/exo4c.R" filename="main.R"}
```
</details>


## Carte des aéroports

La dernière valorisation que nous allons intégrer est une carte interactive
du trafic de nos aéroports. Cette carte va être assez basique. Si vous
désirez mettre en oeuvre des visualisations plus complexes, vous pouvez
tout à fait le faire. 

Pour cet exercice, nous allons fixer une date pour prototyper notre 
code. Cela nous facilitera la transformation ultérieure en fonction. 

```{r}
months <- 1
years <- 2019
```

Voici également une palette de couleurs qui sera utile à la fin de l'exercice. 

```{r}
palette <- c("green", "blue", "red")
```

::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 5: carte aérienne du trafic aéroportuaire

1. Créer un _dataframe_ `trafic_date` en ne conservant que les observations
de `pax_apt_all` égales à un certain mois et année (vous pouvez vous inspirer d'un `filter` fait précédemment). Utiliser celui-ci en faisant
une jointure avec `airports_location` par le biais des variables, respectivement,
`Code.OACI` et `apt`. Nommer ce _dataframe_ `trafic_aeroports`
2. A partir de l'[exemple de démarrage de `leaflet`](https://rstudio.github.io/leaflet/articles/markers.html),
créer une carte interactive qui affiche, lorsqu'on clique sur l'un des
marqueurs, le nom de l'aéroport et sa fréquentation. 
3. Créer une variable nommée `volume` qui classe chaque observation dans son [tercile](https://fr.wiktionary.org/wiki/tercile) et transforme la valeur
en couleur à partir de `palette`.  
4. A partir du code suivant et de la [fonction `addAwesomeMarkers`](https://rstudio.github.io/leaflet/articles/markers.html#awesome-icons),
reproduire une carte similaire à celle présentée plus bas. 

```r
icons <- awesomeIcons(
  icon = 'plane',
  iconColor = 'black',
  library = 'fa',
  markerColor = trafic_aeroports$color
)
```

:::: {.callout-warning collapse="true"}
## Subtilité par rapport à l'exemple de [la documentation](https://rstudio.github.io/leaflet/articles/markers.html#awesome-icons)
Par rapport à l'exemple dans [la documentation](https://rstudio.github.io/leaflet/articles/markers.html#awesome-icons),
il faut légèrement modifier le code de sorte à faire `icon=icons[]`
et non `icon = icons`.
::::
:::


```{r}
#| code-fold: true
#| code-summary: "Question 1"
trafic_date <- pax_apt_all %>%
  mutate(
    date = as.Date(paste(anmois, "01", sep=""), format = "%Y%m%d")
  ) %>%
  filter(mois %in% months, an %in% years)
trafic_aeroports <- airports_location %>%
  inner_join(trafic_date, by = c("Code.OACI" = "apt"))
```


```{r}
#| output: false
#| code-fold: true
#| code-summary: "Question 2"
library(leaflet)
  
leaflet(trafic_aeroports) %>% addTiles() %>%
  addMarkers(popup = ~paste0(Nom, ": ", trafic)) 
```

```{r}
#| code-fold: true
#| code-summary: "Question 3"
trafic_aeroports <- trafic_aeroports %>%
  mutate(
    volume = ntile(trafic, 3)
) %>%
  mutate(
    color = palette[volume]
  )
```  


```{r}
#| code-fold: true
#| code-summary: "Question 3"
icons <- awesomeIcons(
  icon = 'plane',
  iconColor = 'black',
  library = 'fa',
  markerColor = trafic_aeroports$color
)


carte_interactive <- leaflet(trafic_aeroports) %>% addTiles() %>%
  addAwesomeMarkers(
  icon=icons[],
  label=~paste0(Nom, "", " (",Code.OACI, ") : ", trafic, " voyageurs")
)
carte_interactive
```


Comme précédemment, nous proposons
de transformer la production de cette carte en fonction, cela nous permettra
d'avoir une application légère. Là encore c'est un exercice optionnel mais
intéressant à faire pour découvrir la logique de la programmation fonctionnelle. 

::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 5b (optionnel): une fonction pour notre carte

- Créer une fonction `map_leaflet_airport` avec les arguments `df`, `airports_location`
et `selected_date` produisant la carte. Insérer celle-ci dans le script `R/figures.R`
- Mettre à jour `main.R` pour utiliser cette fonction dans votre chaine. N'oubliez pas de
définir `selected_date` dans votre script. 
:::

<details>
<summary>
Code de `R/figures.R` à reprendre
</summary>
```{.r include="R/figures.R" start-line="20" filename="R/figures.R (fin du fichier)"}
```
</details>

<details>
<summary>
Code de `intermediates/exo5.R` à reprendre
</summary>
```{.r include="intermediates/exo5.R" start-line="20" filename="main.R"}
```
</details>


# Création de l'application 

Maintenant tous les ingrédients sont là pour transformer cette chaîne en application
interactive. L'architecture de notre application sera la suivante:

![](img/ui-r.png)

Comme toute application _web_, `Shiny` repose sur deux piliers: 

- l'interface utilisateur (UI) qui présente au navigateur des actions possibles et affiche des _output_ adaptés
- le serveur qui répond à ces actions de l'utilisateur, produit les _output_ et les envoie à l'interface

Supprimer les fichiers `ui.R` et `server.R` dans votre dossier de travail. Nous allons les recréer progressivement afin de comprendre, pas à pas, la logique d'une application.

::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 6: création de la structure de l'application

1. Créer le fichier `global.R` à partir de `main.R` en ne conservant que les lignes jusqu'à la création (incluse)
de l'objet `trafic_aeroports`

<details>
<summary>
Le fichier `global.R` attendu
</summary>
```{.r include="global.R"}
```
</details>

L'objectif de la suite de l'exercice est de comprendre comment fonctionne une
application. Celle-ci sera enrichie ensuite de nos productions graphiques. 

Créer les fichiers `ui.R` et `server.R` à partir des modèles ci-dessous

<details>
<summary>
Code de `ui.R` à reprendre
</summary>
```{.r include="intermediates/exo6/ui.R" filename="ui.R"}
```
</details>

<details>
<summary>
Code de `server.R` à reprendre
</summary>
```{.r include="intermediates/exo6/server.R" filename="server.R"}
```
</details>

Lancer l'application en lançant `shiny::runApp()` depuis la console `R`. Si `firefox` affiche un message de blocage de l'ouverture d'une fenêtre, autoriser celle-ci. 

1. Observer votre console, notamment les messages lors du lancement de l'application
2. Jouer avec les _inputs_ et observer la manière dont l'affichage s'ajuste

Maintenant, se pencher sur le code source et observer l'aller-retour entre les objets du script `ui.R` et `server.R`. 

Tuer l'application avec le bouton stop de la console. 

:::


::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 7: finaliser l'application

Le sujet le plus difficile, quand on découvre `Shiny` est la gestion de la réactivité,
c'est-à-dire de l'aller-retour entre interface utilisateur et serveur. 
Pour comprendre cela, la manière la plus directe est sans doute de se plonger
dans le code de l'application complète:

<details>
<summary>
Code de `ui.R` à reprendre
</summary>
```{.r include="ui.R" filename="ui.R"}
```
</details>

<details>
<summary>
Code de `server.R` à reprendre
</summary>
```{.r include="server.R" filename="server.R"}
```
</details>

1. Observer la manière dont le fichier `ui.R` a évolué. 
2. Observer les nouveaux éléments dans `server.R` et la manière dont ceux-ci sont projetés ensuite dans l'interface utilisateur

:::

::: {.callout-note collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 8 (optionnel): amusez-vous à enrichir l'application

Cette application était un squelette minimal d'application. N'hésitez pas à créer votre propre version. Voici quelques idées:

- Changer l'apparence graphique ;
- Créer une application avec plusieurs pages ; 
- Enrichir les productions graphiques sur l'application...
:::


# Partager cette application: une ouverture vers la mise en production