[
  {
    "objectID": "old/RTraffic.html",
    "href": "old/RTraffic.html",
    "title": "RTraffic",
    "section": "",
    "text": "1 Paramètres\n\nif (!requireNamespace(\"DT\")){install.packages(\"DT\")} #install.packages(\"DT\")#if necessary install package\nt0 = Sys.time()\n\n#stocke les chemins vers les données de trafic dans l'objet \"paths\"\nyear_num = 2018:2022 #to be modified eg c(2019,2022,2023) \nyear_char = as.list(as.character(year_num))\nmonth_char = c(paste0(\"0\", 1:9),10:12)\npaths = data.frame(year_num, c(\"https://www.data.gouv.fr/fr/datasets/r/3b7646ea-276c-4c9b-8151-1e96af2adbf9\", \"https://www.data.gouv.fr/fr/datasets/r/e8efa154-045e-4f8f-a1d7-76a39fa03b7b\", \"https://www.data.gouv.fr/fr/datasets/r/6717f107-be00-4b4b-9706-fa0e5190fb69\", \"https://www.data.gouv.fr/fr/datasets/r/2f9f6e54-e2d7-4e85-b811-2e5e68fa5bca\", \"https://www.data.gouv.fr/fr/datasets/r/f1bd931e-c99e-41ce-865e-9e9785c903ec\"),#url données trafic apt-aéroports sur data.gouv.fr\nc(\"https://www.data.gouv.fr/fr/datasets/r/9c5354ad-31cb-4217-bc88-fb7c9be22655\", \"https://www.data.gouv.fr/fr/datasets/r/0c0a451e-983b-4f06-9627-b5ff1bccd2fc\", \"https://www.data.gouv.fr/fr/datasets/r/dad30bed-7276-4a67-a1ab-a856e6e01788\", \"https://www.data.gouv.fr/fr/datasets/r/bbf6492d-86ac-43a0-9260-7df2ffdb5a77\", \"https://www.data.gouv.fr/fr/datasets/r/af8950bc-e90a-4b7e-bb81-70c79d4c3846\" ),#url données trafic lsn-liaisons sur data.gouv.fr\nc(\"https://www.data.gouv.fr/fr/datasets/r/ddfea6a0-df7e-4402-99fc-165f573f2e10\", \"https://www.data.gouv.fr/fr/datasets/r/8421e029-c8c7-410d-b38c-54455ac3265d\", \"https://www.data.gouv.fr/fr/datasets/r/818eec10-6122-4788-8233-482e779ab837\", \"https://www.data.gouv.fr/fr/datasets/r/0b954774-ccd1-43ec-9b5a-f958fba03e87\", \"https://www.data.gouv.fr/fr/datasets/r/bcec3e1e-940a-4772-bc28-0d7b2b53c718\")#url données trafic cie-compagnies sur data.gouv.fr\n)\nnames(paths) = c(\"year\",\"apt\",\"lsn\",\"cie\")\n\n#charge les fonctions utiles----\nsimplify_text = function(texte){#fonction qui simplifie le texte en retirant la ponctuation et les accents\n  texte=tolower(texte)\n  texte=str_replace_all(texte,\"[:punct:]\",\"\")\n  texte=str_replace_all(texte,\"[:space:]\",\"\")\n  texte=str_replace_all(texte,\"[àâä]\",\"a\")\n  texte=str_replace_all(texte,\"[ç]\",\"c\")\n  texte=str_replace_all(texte,\"[éèêë]\",\"e\")\n  texte=str_replace_all(texte,\"[îï]\",\"i\")\n  texte=str_replace_all(texte,\"[ôö]\",\"o\")\n  texte=str_replace_all(texte,\"[ùûü]\",\"u\")\n  return(texte)}\n    \nload_data = function(data_typ){#fonction qui charge les données dans un dataframe\n  df = NULL\n  for (i in paths[[1]]){\n    print(paste0(data_typ,\" \",i))\n    x = paths %&gt;%\n      select(\"year\", all_of(data_typ)) %&gt;% \n      filter(year == i) #filtre sur l'année sélectionnée\n    df = rbind(df,read.csv(x[[2]], sep = \";\", dec = \",\")) #empile le dataframe sur le précédent\n    }\n  df = df %&gt;% \n    mutate(an = str_sub(ANMOIS,1,4)) %&gt;%\n    mutate(mois = str_sub(ANMOIS,5,6))\n  names(df)=simplify_text(names(df))\n  rm(x,i)\n  return(df)\n  }\n\n#charge les données avec la fonction load_data----\npax_apt = load_data(\"apt\")\npax_cie = load_data(\"cie\")\npax_lsn = load_data(\"lsn\")\ndata_already_loaded = TRUE\nprint(Sys.time()-t0) #mesure le temps machine----\n\n\n\n2 ui\n\nui &lt;- function() {\nfluidPage(\n  verbatimTextOutput(outputId = \"texte\"),\n  checkboxGroupInput(\"mon\", \"Mois : \",\n                     month_char,\n                     inline = T),\n  radioButtons(\"yea\", \"Année : \",\n                     year_char,\n                     inline = T),\n  DT::dataTableOutput(\"table1\"),\n  DT::dataTableOutput(\"table2\")\n)\n}\n\n\n\n3 server\n\nserver &lt;- function(input, output, session) {\n  output$texte &lt;- renderText({\n    paste0(\"Pax in France - DGAC on data.gouv.fr\")\n  })\n  #créé de la réactivité----\n  dfapt = reactive({\n    return(pax_apt %&gt;% filter((mois %in% input$mon)&(an == input$yea)))\n  })\n  dflsn = reactive({\n    return(pax_lsn %&gt;% filter((mois %in% input$mon)&(an == input$yea)))\n  })\n  \n  #créé une table1 de stat par faisceau à partir des données par lsn-liaisons----\n  output$table1 &lt;- DT::renderDataTable(DT::datatable({\n    data = bind_cols(\n      bind_rows(\n        dflsn() %&gt;% summarise(paxloc = round(sum(lsnpaxloc, na.rm = T)/1000000,3)),\n        dflsn() %&gt;%\n          group_by(lsnfsc) %&gt;%\n          summarise(paxloc = round(sum(lsnpaxloc, na.rm = T)/1000000,3)) %&gt;%\n          ungroup\n      )\n    )\n  }, class = \"cell-border compact hover stripe\",\n  options = list(\n    autoWidth = T,\n    columnDefs = list(list(width = '20px', targets = c(0,1,2))),\n    dom = \"Bfrtip\", \n    scrollY = 145, scrollX = 400, scroller = TRUE,\n    fixedColumns = list(leftColumns = 1),\n    select = list(style = 'os', items = 'row'),\n    buttons = c(\n      'copy', 'csv',\n      'colvis',\n      'selectAll', 'selectNone', 'selectRows', 'selectColumns', 'selectCells'\n    )\n  )))\n  \n  #créé une table2 de stat par aéroport à partir des données par apt-aéroports----\n  output$table2 = DT::renderDataTable(DT::datatable({\n    data = bind_rows(\n      dfapt() %&gt;%\n        group_by(apt, aptnom) %&gt;%\n        summarise(paxdep = round(sum(aptpaxdep, na.rm = T)/1000000,3), paxarr = round(sum(aptpaxarr, na.rm = T)/1000000,3), paxtra = round(sum(aptpaxtr, na.rm = T)/1000000,3)) %&gt;%\n        arrange(desc(paxdep)) %&gt;%\n        ungroup\n    )\n  }, class = \"cell-border compact hover stripe\",\n  extensions = c(\"Scroller\", \"FixedColumns\", \"Buttons\", \"Select\"), \n  selection = \"none\",\n  options = list(\n    autoWidth = T,\n    columnDefs = list(list(width = '20px', targets = c(0,1,2))),\n    dom = \"Bfrtip\", \n    scrollY = 145, scrollX = 400, scroller = TRUE,\n    fixedColumns = list(leftColumns = 1),\n    select = list(style = 'os', items = 'row'),\n    buttons = c(\n      'copy', 'csv',\n      'colvis',\n      'selectAll', 'selectNone', 'selectRows', 'selectColumns', 'selectCells'\n    )\n  )))\n  }\n\n\n\n4 shiny\n\nshinyApp(ui, server)#lance le tableau de bord en shiny"
  },
  {
    "objectID": "index.html#objectif",
    "href": "index.html#objectif",
    "title": "Un tableau de bord du trafic aérien avec  ou ",
    "section": "0.1 Objectif",
    "text": "0.1 Objectif\nL’objectif de ce tutoriel est d’amener, pas à pas, à la conception voire à la mise à disposition d’un tableau de bord (dashboard) du trafic aérien avec . Une démonstration de cette application est disponible à l’adresse https://rplane-dashboard.kub.sspcloud.fr/.\nAfin de se concentrer sur la démarche, cette application interactive présentera un nombre limité de fonctionnalités limitées. L’objectif est de construire progressivement celle-ci en suivant les étapes logiques du déroulement d’un projet de développement d’application interactive: découverte et exploration des données, création de statistiques descriptives et de visualisations simples sur un jeu de données, extension du nombre de visualisations accessibles par la création d’une application. Ce tutoriel est également l’occasion de découvrir quelques bonnes pratiques de programmation avec  afin de rendre les projets plus fiables, évolutifs et lisibles.\nLes exercices de conception pas à pas de l’application s’adressent aussi bien à des débutants qu’à des utilisateurs plus experts. La mise à disposition, c’est-à-dire la mise en production de cette application, fait appel à des concepts et outils plus avancés et est donc moins accessible à des débutants.\n\n\n\n\n\n\nTip\n\n\n\nSi vous désirez aller plus loin sur certaines dimensions de ce projet, vous pouvez tout à fait essayer de vous-mêmes d’introduire de nouveaux ingrédients dans l’application que vous développez."
  },
  {
    "objectID": "index.html#pourquoi-faire-une-application-interactive",
    "href": "index.html#pourquoi-faire-une-application-interactive",
    "title": "Un tableau de bord du trafic aérien avec  ou ",
    "section": "0.2 Pourquoi faire une application interactive ?",
    "text": "0.2 Pourquoi faire une application interactive ?\nCette question peut apparaître naive. Pourtant, elle mérite d’être posée car elle permet de réfléchir à la cible de l’application,\nElle est néanmoins fondamentale car elle définit la nature de la"
  },
  {
    "objectID": "index.html#préliminaire-récupérer-le-projet-squelette-avec-git-fa-brands-git-alt",
    "href": "index.html#préliminaire-récupérer-le-projet-squelette-avec-git-fa-brands-git-alt",
    "title": "Un tableau de bord du trafic aérien avec  ou ",
    "section": "1.1 Préliminaire: récupérer le projet squelette avec Git ",
    "text": "1.1 Préliminaire: récupérer le projet squelette avec Git \nSi vous disposez d’un compte sur le sspcloud, la méthode recommandée pour se lancer dans ce tutoriel est de cliquer sur le bouton suivant\n\n\n\n\nSi vous avez utilisé le lien de lancement rapide mis à disposition sur la page inseefrlab.github.io/funathon2024/ ou ci-dessus, vous pouvez sauter l’étape de récupération du modèle de projet avec Git, cela a été fait automatiquement lors de la création de votre environnement RStudio.\n\n\n\n\n\n\nRécupérer le projet si vous n’avez pas utilisé le bouton proposé\n\n\n\n\n\n\nInterface graphiqueDepuis le terminal\n\n\nLa fiche utilitR sur l’utilisation de Git explicite la démarche générale pour récupérer du code grâce à Git. Il est recommandé de lire celle-ci si vous n’êtes pas familier de Git.\nLes étapes suivantes permettront de récupérer le projet:\n1️⃣ En premier lieu, dans RStudio, créer un nouveau projet et sélectionner Version Control.\n\n2️⃣ Choisir Git, ce qui devrait ouvrir une fenêtre similaire à celle ci-dessous:\n\n3️⃣ Dans la fenêtre Repository URL, passer la valeur\nhttps://github.com/inseefrlab/funathon2024_sujet2.git\nlaisser les valeurs par défaut qui viennent ensuite et créer le projet.\n\n\nAprès avoir ouvert un terminal dans RStudio, faire\ngit clone https://github.com/inseefrlab/funathon2024_sujet2.git\npuis, dans l’explorateur de fichiers (fenêtre en bas à droite), cliquer sur le fichier RTraffic.Rproj pour ouvrir le projet.\n\n\n\n\n\n\nLe projet récupéré comporte de nombreux fichiers. Nous allons progressivement les découvrir dans ce tutoriel. A l’heure actuelle, on peut se concentrer sur les fichiers suivants:\n|- renv.lock\n|- global.R\n|- server.R\n|- ui.R\nLe premier fichier correspond à la liste des packages nécessaires pour reproduire l’environnement. Il a été généré automatiquement grâce à un écosystème renv particulièrement adapté pour assurer la reproductibilité de projets R (voir la suite).\nLes fichiers server.R et ui.R constituent le coeur de notre application Shiny. Ils représentent, respectivement, le moteur de calcul (le serveur) et l’interface utilisateur de notre application. Le fichier global.R stocke un certain nombre d’objets utiles à l’application mais qui n’ont pas besoin d’être recalculé à chaque action sur l’interface graphique."
  },
  {
    "objectID": "index.html#installer-les-packages-nécessaires-pour-ce-tutoriel",
    "href": "index.html#installer-les-packages-nécessaires-pour-ce-tutoriel",
    "title": "Un tableau de bord du trafic aérien avec  ou ",
    "section": "1.2 Installer les packages nécessaires pour ce tutoriel",
    "text": "1.2 Installer les packages nécessaires pour ce tutoriel\n\n1.2.1 Principe\nPour progresser dans ce tutoriel, un certain nombre de packages doivent être installés. Sans eux, même avec le code de l’application, vous ne serez pas en mesure de reproduire celle-ci.\nLes bonnes pratiques pour la gestion de l’environnement sont assez proches en  et . Le principal général est qu’il existe des outils qui permettent à un utilisateur de lister l’ensemble des packages dans son environnement avec leur version. Grâce à cette liste, d’autres personnes pourront reproduire l’application si elles disposent des mêmes inputs (le code, les données…).\nEn effet, il est important de voir l’application comme le résultat de la combinaison de plusieurs ingrédients. Dans notre cas, nous en avons trois:\n\nDu code R ou Python : celui-ci a été récupéré par le biais de Git\nDes éléments de configuration:\n\nle fichier renv.lock (R) ou requirements.txt (Python) qui permettra de reconstruire notre environnement à l’identique grâce à des outils adaptés1\nle fichier sources.yaml qui liste l’emplacement des sources sur le site data.gouv\n\nDes données: nous évoquerons celles-ci lors de la prochaine partie.\n\n\n\n\nIllustration du principe de séparation du code, des données et de la configuration\n\n\nDe manière générale, c’est une bonne pratique de structurer son projet comme une combinaison de ces facteurs. Cela vous amènera à faire des projets plus reproductible mais aussi à la structure plus lisible.\nPour les utilisateurs de R, la formation de l’Insee aux bonnes pratiques consacre une partie aux environnements reproductibles avec renv. Pour les utilisateurs de Python, le cours de mise en production de projets data science consacre un chapitre au sujet.\n\n\n1.2.2 Créer l’environnement\nL’intérêt d’utiliser renv est que recréer l’environnement nécessaire au bon fonctionnement de l’application est très simple avec la commande:\nrenv::restore()\nIl est tout à fait possible, ensuite, d’installer des packages supplémentaires par le biais de install.packages. L’environnement proposé par notre fichier renv.lock est le minimum requis pour reproduire l’application mais ce n’est pas un environnement figé. Si vous ajoutez des packages utiles pour votre application, avant la phase de mise en production, n’oubliez pas de faire renv::snapshot() pour mettre à jour le fichier renv.lock.\nMaintenant que nous disposons d’un environnement fonctionnel, nous pouvons avancer sur la conception du projet. La première étape est d’explorer les jeux de données que nous utiliserons dans l’application"
  },
  {
    "objectID": "index.html#importer-la-liste-des-sources-disponibles",
    "href": "index.html#importer-la-liste-des-sources-disponibles",
    "title": "Un tableau de bord du trafic aérien avec  ou ",
    "section": "2.1 Importer la liste des sources disponibles",
    "text": "2.1 Importer la liste des sources disponibles\n\n\n\n\n\n\n Exercice 1: lire les sources dans \n\n\n\n\n\n\nLe package yaml comporte une fonction read_yaml pour transformer un fichier YAML en liste imbriquée. Tester cette fonction sur le fichier sources.yml.\nTransformer ce bout de code en une fonction create_data_list prenant un argument source_file et renvoyant cette liste.\n\n\n\n\n\n\nVoir la solution\n\n#' Creates a 2-levels list of urls, pointing to open source data\n#' \n#' @param source_file yaml file containing data urls \n#' @return list (level 1 = concepts, level 2 = year).\n#'\n#' @examples\n#'  create_data_list(\"sources.yml\")\n#'  \ncreate_data_list &lt;- function(source_file){\n  catalogue &lt;- yaml::read_yaml(source_file)\n  return(catalogue)\n}\n\nLa solution est dans le fichier R/create_data_list.R. Elle peut être importée dans l’environnement global grâce à la commande:\n\nsource(\"R/create_data_list.R\")"
  },
  {
    "objectID": "index.html#importer-les-premières-bases",
    "href": "index.html#importer-les-premières-bases",
    "title": "Un tableau de bord du trafic aérien avec  ou ",
    "section": "2.2 Importer les premières bases",
    "text": "2.2 Importer les premières bases\n\nurls &lt;- create_data_list(\"sources.yml\")\n\n\n\n\n\n\n\n Exercice 2: découvrir les différentes sources\n\n\n\n\n\nCet exercice est, en apparence, un peu long. Néanmoins la première partie de celui-ci permet la construction d’une fonction générique d’import des données qui permet ensuite de gagner du temps et d’éviter la redondance de code.\n\nDonnées aéroports\n\nComme les données sont des CSV européens (séparateur ;), utiliser read_csv2 du package readr pour lire les données à partir de la liste de fichiers unlist(urls$airports)2.\nIl est recommandé de ne pas laisser les types par défaut des colonnes mais de figer ceux-ci avec l’argument suivant:\n\ncol_types = cols(\n  ANMOIS = col_character(),\n  APT = col_character(),\n  APT_NOM = col_character(),\n  APT_ZON = col_character(),\n  .default = col_double()\n)\n\nA partir de la variable ANMOIS, créer les variables an et mois.\n\n\n\nAide si vous êtes bloqué sur cette question\n\nPour extraire des éléments d’une chaine de caractère à partir de la position, il est recommandé d’utiliser la fonction str_sub du package stringr. Pour créer de nouvelles colonnes, il est recommandé d’utiliser la fonction mutate du package dplyr.\n\n\n\n\n\n\nConseil pour se faciliter la vie ultérieurement\n\n\n\nIl est recommandé d’utiliser str_remove pour retirer les zéros en début de mois qui pourront nous créer des difficultés ultérieurement\n\n\nSi vous êtes toujours bloqué, la solution est donnée plus bas 👇\n\n\nCréer une fonction clean_dataframe qui reprend le code de création des variables an et mois, ajoute une étape de passage des noms de colonne en minuscule et renvoie le dataframe en sortie\n\n\n\nSolution\n\nclean_dataframe &lt;- function(df){\n  \n  # Create an et mois columns\n  df &lt;- df %&gt;% \n    mutate(\n      an = str_sub(ANMOIS,1,4),\n      mois = str_sub(ANMOIS,5,6)\n    ) %&gt;%\n    mutate(\n      mois = str_remove(mois, \"^0+\")\n    )\n  \n  # lower case for variable names\n  colnames(df) &lt;- tolower(colnames(df))\n  \n  return(df)\n\n}\n\n\nCréer une fonction import_airport_data qui prend en input list_files et intègre les deux étapes précédentes: la lecture des données, le nettoyage avec clean_dataframe.\n\n\n\nSolution\n\nimport_airport_data &lt;- function(list_files){\n  \n  pax_apt_all &lt;- readr::read_csv2(\n    list_files, \n    col_types = cols(\n      ANMOIS = col_character(),\n      APT = col_character(),\n      APT_NOM = col_character(),\n      APT_ZON = col_character(),\n      .default = col_double()\n    )\n  ) %&gt;% \n    clean_dataframe()\n  \n  return(pax_apt_all)\n  \n}\n\nReporter cette fonction dans un fichier R/clean_dataframe.R et faire\n\nsource(\"R/clean_dataframe.R\")\n\n\n\nDonnées compagnies\nSur le même principe, créer une fonction import_compagnies_data qui effectue la même suite d’opérations. Faire néanmoins attention aux types des colonnes.\n\n\nRecommandation de paramètre pour read_csv pour l’import de ces fichiers\ncol_types = cols(\n  ANMOIS = col_character(),\n  CIE = col_character(),\n  CIE_NOM = col_character(),\n  CIE_NAT = col_character(),\n  CIE_PAYS = col_character(),\n  .default = col_double()\n)\n\n\n\n\nSolution\n\nimport_compagnies_data &lt;- function(list_files){\n  \n  pax_cie_all &lt;- readr::read_csv2(\n    file = list_files,\n    col_types = cols(\n      ANMOIS = col_character(),\n      CIE = col_character(),\n      CIE_NOM = col_character(),\n      CIE_NAT = col_character(),\n      CIE_PAYS = col_character(),\n      .default = col_double()\n    )\n  ) %&gt;% \n    clean_dataframe()\n  \n  return(pax_cie_all)\n  \n  \n}\n\n\n\nDonnées liaisons\nSur le même principe, créer une fonction import_liaisons_data qui effectue la même suite d’opérations. Faire néanmoins attention aux types des colonnes.\n\n\nRecommandation de paramètre pour read_csv pour l’import de ces fichiers\ncol_types = cols(\n  ANMOIS = col_character(),\n  LSN = col_character(),\n  LSN_DEP_NOM = col_character(),\n  LSN_ARR_NOM = col_character(),\n  LSN_SCT = col_character(),\n  LSN_FSC = col_character(),\n  .default = col_double()\n)\n\n\n\n\nSolution\n\nimport_liaisons_data &lt;- function(list_files){\n  \n  pax_lsn_all &lt;- readr::read_csv2(\n    file = list_files,\n    col_types = cols(\n      ANMOIS = col_character(),\n      LSN = col_character(),\n      LSN_DEP_NOM = col_character(),\n      LSN_ARR_NOM = col_character(),\n      LSN_SCT = col_character(),\n      LSN_FSC = col_character(),\n      .default = col_double()\n    ) \n  ) %&gt;% \n    clean_dataframe()\n  \n  return(pax_lsn_all)\n  \n  \n}\n\n\n\nLocalisations des aéroports\nIl s’agit d’un jeu de données spatial. Pour en savoir plus sur ce type de données, il est recommandé de consulter la fiche utilitR sur le sujet ou ce cours introductif\n\nUtiliser la fonction st_read du package sf pour lire ces données (dont la localisation est stockée dans la variable urls$geojson$aiport). Stocker l’objet obtenu sous le nom airports_location\nVérifier que les données sont bien dans le système de représentation WGS 843\n\n\n\nAide\n\nLa fonction à utiliser est sf_crs\n\n\nIl est toujours utile de vérifier que nos données sont bien localisées où on les attend. Pour cela, il est pertinent de faire une carte avec un fond de carte contextuel, même si celle-ci n’est pas très soignée. Pour faire ceci, le plus simple est d’utiliser la fonction addMarkers du package leaflet. Essayez de faire cette carte vous-mêmes ou consultez l’aide ci-dessous\n\n\n\nCode pour faire une carte leaflet minimale\n\nleaflet(airports_location) %&gt;%\n  addTiles() %&gt;%\n  addMarkers(popup = ~Nom)\n\nReporter toutes ces fonctions dans un fichier R/import_data.R.\n\n\n\n\nA l’issue de cet exercice, vous devriez avoir le fichier R/import_data.R suivant\n\n\nLe fichier R/import_data.R attendu\n\nimport_airport_data &lt;- function(list_files){\n  \n  pax_apt_all &lt;- readr::read_csv2(\n    list_files, \n    col_types = cols(\n      ANMOIS = col_character(),\n      APT = col_character(),\n      APT_NOM = col_character(),\n      APT_ZON = col_character(),\n      .default = col_double()\n    )\n  ) %&gt;% \n    clean_dataframe()\n  \n  return(pax_apt_all)\n  \n}\n\n\nimport_compagnies_data &lt;- function(list_files){\n  \n  pax_cie_all &lt;- readr::read_csv2(\n    file = list_files,\n    col_types = cols(\n      ANMOIS = col_character(),\n      CIE = col_character(),\n      CIE_NOM = col_character(),\n      CIE_NAT = col_character(),\n      CIE_PAYS = col_character(),\n      .default = col_double()\n    )\n  ) %&gt;% \n    clean_dataframe()\n  \n  return(pax_cie_all)\n  \n  \n}\n\n\nimport_liaisons_data &lt;- function(list_files){\n  \n  pax_lsn_all &lt;- readr::read_csv2(\n    file = list_files,\n    col_types = cols(\n      ANMOIS = col_character(),\n      LSN = col_character(),\n      LSN_DEP_NOM = col_character(),\n      LSN_ARR_NOM = col_character(),\n      LSN_SCT = col_character(),\n      LSN_FSC = col_character(),\n      .default = col_double()\n    ) \n  ) %&gt;% \n    clean_dataframe()\n  \n  return(pax_lsn_all)\n  \n  \n}\n\nLa carte leaflet que vous devriez avoir obtenue à la fin de l’exercice est la suivante:\n\nleaflet(airports_location) %&gt;%\n  addTiles() %&gt;%\n  addMarkers(popup = ~Nom)\n\n\n\n\n\nA l’issue de l’exercice, le code centralisé dans le script R/import_data.R peut être importé via le code suivant\n\nsource(\"R/import_data.R\")  \n\nVous pouvez initier un script nommé main.R avec les lignes suivante:\nMONTHS_LIST = 1:12\n\n# Load data ----------------------------------\nurls &lt;- create_data_list(\"./sources.yml\")\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\nen les faisant précéder de l’import des scripts que nous avons déjà créé dans le dossier R:\nsource(\"R/create_data_list.R\")\nsource(\"R/import_data.R\")  \nsource(\"R/clean_dataframe.R\")\nUne bonne pratique est de tester son script dans une session vierge. Cela amène à construire pas à pas une chaine plus reproductible. Pour cela,\n\nAller dans les options de R via Tools &gt; Global Options et décocher la case Restore .RData into workspace at setup\nRedémarrer votre session R via le menu Session &gt; Restart R ou le raccourci CTRL+SHIFT+F10\n\nEt exécuter votre fichier main.R. Vous devriez rencontrer des erreurs car nous n’avons pas géré les import de librairies dans ce script puisque notre session actuelle ne bénéficie plus des import antérieurs.\nUne bonne pratique pour comprendre cette exigence de reproductibilité est d’itérativement ajouter les librairies utiles à mesure qu’on rencontre des erreurs (notre code étant très rapide à tourner, cette logique d’essai-erreur n’est pas très coûteuse). Si vous ne désirez pas faire ceci (dommage, c’est un bon exercice), vous pouvez trouver les imports de packages à faire pour que notre script soit reproductible.\n\n\nL’environnement minimal de reproductibilité pour que le script main.R fonctionne\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sf)\n\nCes librairies sont à écrire au début de main.R."
  },
  {
    "objectID": "index.html#le-trafic-par-aéroport",
    "href": "index.html#le-trafic-par-aéroport",
    "title": "Un tableau de bord du trafic aérien avec  ou ",
    "section": "3.1 Le trafic par aéroport",
    "text": "3.1 Le trafic par aéroport\nPour commencer, nous allons prototyper la production d’une figure sur le trafic aérien au niveau d’un aéroport. Cela nous facilitera ensuite l’intégration dans une application interactive.\nPour cela, nous allons créer les deux objets temporaires suivants\n\nliste_aeroports &lt;- unique(pax_apt_all$apt)\ndefault_airport &lt;- liste_aeroports[1]\ndefault_airport\n\n[1] \"FMCZ\"\n\n\n\n\n\n\n\n\n Exercice 3: graphiques de fréquentation des aéroports\n\n\n\n\n\n\nCréer une variable trafic égale apt_pax_dep + apt_pax_tr + apt_pax_arr\nNe conserver que les données relatives à l’aéroport default_airport\nCréer une variable date qui utilise les colonnes an et mois. Cette variable de date doit être au format date, pas au format chr\n\n\nEnchaînement des opérations attendues à cette étape\n\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sf)\nlibrary(plotly)\n\nsource(\"R/import_data.R\")\nsource(\"R/create_data_list.R\")\nsource(\"R/clean_dataframe.R\")\nsource(\"R/figures.R\")\n\n\n# Load data ----------------------------------\nurls &lt;- create_data_list(\"./sources.yml\")\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\n\nliste_aeroports &lt;- unique(pax_apt_all$apt)\ndefault_airport &lt;- liste_aeroports[1]\n\n\ntrafic_aeroports &lt;- pax_apt_all %&gt;%\n  mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr) %&gt;%\n  filter(apt %in% default_airport) %&gt;%\n  mutate(\n    date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n  )\n\n\nFaire une figure ggplot toute simple pour voir la dynamique des données afin d’obtenir une figure similaire à celle-ci\n\n\nfigure_ggplot\n\n\n\n\nNous allons faire une application interactive par la suite. Il est donc plus intéressant d’avoir une figure un minimum réactive pour impliquer l’utilisateur de l’application.\n\nIl est donc plus pertinent de faire une figure avec la librairie plotly. Pour cela, vous pouvez vous inspirer de cette page\n\n\n\n\n\n\n\n\n\nLe code pour générer la figure\n\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\n\nliste_aeroports &lt;- unique(pax_apt_all$apt)\ndefault_airport &lt;- liste_aeroports[1]\n\n\ntrafic_aeroports &lt;- pax_apt_all %&gt;%\n  mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr) %&gt;%\n  filter(apt %in% default_airport) %&gt;%\n  mutate(\n    date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n  )\n\n\n# VALORISATIONS ----------------------------------------------\n\nfigure_ggplot &lt;- trafic_aeroports %&gt;%\n  ggplot(.) + geom_line(aes(x = date, y = trafic))\n\nfigure_plotly &lt;- plot_airport_line(trafic_aeroports,default_airport)\n\n\n\n\nLe code complet pour répliquer cet exercice est donné ci-dessous.\n\n\nCode de l’exercice\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sf)\nlibrary(plotly)\n\nsource(\"R/import_data.R\")\nsource(\"R/create_data_list.R\")\nsource(\"R/clean_dataframe.R\")\nsource(\"R/figures.R\")\n\n\n# Load data ----------------------------------\nurls &lt;- create_data_list(\"./sources.yml\")\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\n\nliste_aeroports &lt;- unique(pax_apt_all$apt)\ndefault_airport &lt;- liste_aeroports[1]\n\n\ntrafic_aeroports &lt;- pax_apt_all %&gt;%\n  mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr) %&gt;%\n  filter(apt %in% default_airport) %&gt;%\n  mutate(\n    date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n  )\n\n\n# VALORISATIONS ----------------------------------------------\n\nfigure_ggplot &lt;- trafic_aeroports %&gt;%\n  ggplot(.) + geom_line(aes(x = date, y = trafic))\n\nfigure_plotly &lt;- plot_airport_line(trafic_aeroports,default_airport)\n\nNous proposons de le transformer en fonction, ce sera plus simple à intégrer ultérieurement dans notre application\n\n\n\n\n\n\n Exercice 3b: une fonction de production graphique\n\n\n\n\n\nTransformer le code ci-dessus en une fonction afin que\n\nles inputs soient les suivants: un dataframe, un aéroport à sélectionner\nla sortie soit notre figure plotly\n\nTester la fonction sur d’autres aéroports de la liste. Quand vous êtes satisfaits de celle-ci, déplacer la définition de cette fonction dans R/figures.R\n\n\n\n\n\nFichier R/figures.R à l’issue de cet exercice\n\n\n\nR/figures.R\n\n\nplot_airport_line &lt;- function(df, selected_airport){\n  trafic_aeroports &lt;- df %&gt;%\n    mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr) %&gt;%\n    filter(apt %in% selected_airport) %&gt;%\n    mutate(\n      date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n    )\n  \n  figure_plotly &lt;- trafic_aeroports %&gt;%\n    plot_ly(\n      x = ~date, y = ~trafic,\n      text = ~apt_nom,\n      hovertemplate = paste(\"&lt;i&gt;Aéroport:&lt;/i&gt; %{text}&lt;br&gt;Trafic: %{y}\") ,\n      type = 'scatter', mode = 'lines+markers')\n  \n  return(figure_plotly)\n}\n\n\nPar la suite, nous pouvons ajouter la ligne suivante à notre fichier main.R\n\nsource(\"R/figures.R\")\n\net utiliser cette fonction à la fin du fichier.\n\n\nFichier main.R à l’issue de cet exercice\n\n\n\nmain.R\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sf)\nlibrary(plotly)\n\nsource(\"R/import_data.R\")\nsource(\"R/create_data_list.R\")\nsource(\"R/clean_dataframe.R\")\nsource(\"R/figures.R\")\n\n\n# Load data ----------------------------------\nurls &lt;- create_data_list(\"./sources.yml\")\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\n\nliste_aeroports &lt;- unique(pax_apt_all$apt)\ndefault_airport &lt;- liste_aeroports[1]\n\n\ntrafic_aeroports &lt;- pax_apt_all %&gt;%\n  mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr) %&gt;%\n  filter(apt %in% default_airport) %&gt;%\n  mutate(\n    date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n  )\n\n\n# VALORISATIONS ----------------------------------------------\n\nfigure_ggplot &lt;- trafic_aeroports %&gt;%\n  ggplot(.) + geom_line(aes(x = date, y = trafic))\n\nfigure_plotly &lt;- plot_airport_line(trafic_aeroports,default_airport)"
  },
  {
    "objectID": "index.html#tableau-html-pour-afficher-des-données",
    "href": "index.html#tableau-html-pour-afficher-des-données",
    "title": "Un tableau de bord du trafic aérien avec  ou ",
    "section": "3.2 Tableau HTML pour afficher des données",
    "text": "3.2 Tableau HTML pour afficher des données\nLa première valorisation que nous intégrerons dans notre application est le modèle de figure ci-dessus. La deuxième sera un tableau permettant de visualiser certaines données directement dans le dashboard.\nPour le prochain exercice, vous pourrez utiliser ces objets\n\nYEARS_LIST  &lt;- as.character(2018:2022)\nMONTHS_LIST &lt;- 1:12\n\n\n\n\n\n\n\n Exercice 4a: préparer les données avant de faire un beau tableau\n\n\n\n\n\nNous allons intégrer dans notre application deux tableaux de statistiques descriptives.\n\nChoisir un mois et une année à partir des objets YEARS_LIST et MONTHS_LIST pour faire un filtre sur le dataframe pax_apt_all. Une fois que vous êtes satisfaits, transformer cela en fonction create_data_from_input prenant en argument un dataframe, une année et un mois\n\n\n\nCode de l’exercice\n\ncreate_data_from_input &lt;- function(data, years, months){\n  data &lt;- data %&gt;%\n    filter(mois %in% months, an %in% years)\n  return(data)\n}\n\n\n\nPour chaque aéroport, calculer le nombre total de passager. Rapporter cette statistique en million de personnes. Puis classer les aérports du plus fréquenté au moins fréquenté. Une fois que vous êtes satisfaits de votre chaine d’opération, créer une fonction summary_stat_airport.\n\n\n\nCode de l’exercice\n\n  table2 &lt;- data %&gt;%\n    group_by(apt, apt_nom) %&gt;%\n    summarise(\n      paxdep = round(sum(apt_pax_dep, na.rm = T),3),\n      paxarr = round(sum(apt_pax_arr, na.rm = T),3),\n      paxtra = round(sum(apt_pax_tr, na.rm = T),3)) %&gt;%\n    arrange(desc(paxdep)) %&gt;%\n    ungroup()\n  \n  return(table2)\n}\n\n\n\nVoici une fonction pour faire le même type d’opération sur la base des liaisons.\n\n\n\nCode de l’exercice\n\n  agg_data &lt;- data %&gt;%\n    group_by(lsn_fsc) %&gt;%\n    summarise(\n      paxloc = round(sum(lsn_pax_loc, na.rm = TRUE)*1e-6,3)\n    ) %&gt;%\n    ungroup()\n  return(agg_data)\n}\n\n\nReporter les fonctions créées dans cet exercice dans un script divers_functions.R. Enrichir le script main.R pour utiliser celles-ci en créant les dataframes adéquats (correction ci-dessous)\n\n\n\nVoici une proposition de script main.R à l’issue de cet exercice\n\n\nCode de l’exercice\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(plotly)\nlibrary(leaflet)\n\nsource(\"R/import_data.R\")\nsource(\"R/create_data_list.R\")\nsource(\"R/clean_dataframe.R\")\nsource(\"R/divers_functions.R\")\nsource(\"R/figures.R\")\n\nYEARS_LIST  &lt;- as.character(2018:2022)\nMONTHS_LIST &lt;- 1:12\nyear &lt;- YEARS_LIST[1]\nmonth &lt;- MONTHS_LIST[1]\n\n\n# Load data ----------------------------------\nurls &lt;- create_data_list(\"./sources.yml\")\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\n\nliste_aeroports &lt;- unique(pax_apt_all$apt)\ndefault_airport &lt;- liste_aeroports[1]\n\n# OBJETS NECESSAIRES A L'APPLICATION ------------------------\n\ntrafic_aeroports &lt;- pax_apt_all %&gt;%\n  mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr) %&gt;%\n  filter(apt %in% default_airport) %&gt;%\n  mutate(\n    date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n  )\n\nstats_aeroports &lt;- summary_stat_airport(\n  create_data_from_input(pax_apt_all, year, month)\n)\nstats_liaisons  &lt;- summary_stat_liaisons(\n  create_data_from_input(pax_lsn_all, year, month)\n)\n\n\n# VALORISATIONS ----------------------------------------------\n\nfigure_plotly &lt;- plot_airport_line(trafic_aeroports,default_airport)\n\n\nNous avons maintenant tous les ingrédients pour faire un tableau de statistiques descriptives lisible et esthétique. Pour cela, nous allons utiliser le package GT. Avant de créer cette table, nous allons créer une colonne supplémentaire:\n\nstats_aeroports_table &lt;- stats_aeroports %&gt;%\n  mutate(name_clean = paste0(str_to_sentence(apt_nom), \" _(\", apt, \")_\")\n) %&gt;%\nselect(name_clean, everything())\n\nCelle-ci nous permettra, une fois mise en forme, d’avoir une colonne plus esthétique.\n\n\n\n\n\n\n Exercice 4b: un beau tableau (enfin !)\n\n\n\n\n\nLes différentes questions vont permettre de construire et formatter progressivement notre tableau. Si vous êtes bloqués, les réponses sont ci-dessous dans des menus déroulants.\n\nEn premier lieu, utiliser GT pour faire un tableau basique sur le dataframe stats_aeroports_table. N’utiliser aucune option, celles-ci vont être progressivement ajoutées.\nRetirer les colonnes apt et apt_nom de notre table.\n\n\n\nIl y a plusieurs manières de faire, voici un indice sur la “meilleure”\n\nIl est possible d’utiliser des fonctions de sélection de colonnes issues du tidyverse dans gt, notamment la fonction starts_with (à ne pas confondre avec celle de stringr)\n\n\nFormatter les colonnes numériques (pour la sélection des colonnes numériques, voir l’indice ci-dessus). En consultant la documentation de gt, appliquer l’option qui permet de rendre plus concise la notation des milliers (K) et millions (M).\nUtiliser fmt_markdown pour appliquer une mise en forme adaptée à la colonne name_clean\nMettre en forme les noms de colonne (cols_labels), le titre (tab_header) et la couleur de la partie supérieure du tableau (tab_style), les notes (tab_source_note) pour avoir un tableau esthéthique et informatif\nTransformer la table en tableau interactif avec opt_interactive4\n\n\n\n\nLes réponses aux différentes questions sont données de manière successives ci-dessous. La table finale, obtenue à l’issue de l’exercice est la suivante:\n\n\nRéponse question 1\nlibrary(gt)\ntable_aeroports &lt;- gt(stats_aeroports_table)\ntable_aeroports\n\n\n\n\nRéponse question 2\ntable_aeroports &lt;- table_aeroports %&gt;%\n  cols_hide(columns = starts_with(\"apt\"))\ntable_aeroports\n\n\n\n\nRéponse question 3\ntable_aeroports &lt;- table_aeroports %&gt;%\n  fmt_number(columns = starts_with(\"pax\"), suffixing = TRUE)\ntable_aeroports\n\n\n\n\nRéponse question 4\ntable_aeroports &lt;- table_aeroports %&gt;%\n  fmt_markdown(columns = \"name_clean\")\ntable_aeroports\n\n\n\n\nRéponse question 5\ntable_aeroports &lt;- table_aeroports %&gt;%\n  cols_label(\n    name_clean = md(\"**Aéroport**\"),\n    paxdep = md(\"**Départs**\"),\n    paxarr = md(\"**Arrivée**\"),\n    paxtra = md(\"**Transit**\")\n  ) %&gt;%\n  tab_header(\n    title = md(\"**Statistiques de fréquentation**\"),\n    subtitle = md(\"Classement des aéroports\")\n  ) %&gt;%\n  tab_style(\n    style = cell_fill(color = \"powderblue\"),\n    locations = cells_title()\n  ) %&gt;%\n  tab_source_note(source_note = md(\"_Source: DGAC, à partir des données sur data.gouv.fr_\"))\n  \ntable_aeroports\n\n\n\n\nRéponse question 6\ntable_aeroports &lt;- table_aeroports %&gt;%\n  opt_interactive()\ntable_aeroports\n\n\n\n\n\n\nStatistiques de fréquentation\nClassement des aéroports\n\n\n\n\n\n\nSource: DGAC, à partir des données sur data.gouv.fr\n\n\n\n\n\n\n\n\n\nNous proposons de transformer ce code en fonction, cela facilitera l’utilisation ultérieure de celui-ci dans notre application.\n\n\n\n\n\n\n Exercice 4c (optionnel): transformer en fonction notre chaîne gt\n\n\n\n\n\nCet exercice est optionnel. Transformer le code ci-dessus en fonction. Mettre à jour main.R pour utiliser ceci dans votre application.\n\n\n\n\n\nCode de R/tables.R\n\n\n\nR/tables.R\n\ncreate_table_airports &lt;- function(stats_aeroports){\n\n  stats_aeroports_table &lt;- stats_aeroports %&gt;%\n    mutate(name_clean = paste0(str_to_sentence(apt_nom), \" _(\", apt, \")_\")\n    ) %&gt;%\n    select(name_clean, everything())\n    \n  table_aeroports &lt;- gt(stats_aeroports_table)\n  \n  table_aeroports &lt;- table_aeroports %&gt;%\n    cols_hide(columns = starts_with(\"apt\"))\n  \n  table_aeroports &lt;- table_aeroports %&gt;%\n    fmt_number(columns = starts_with(\"pax\"), suffixing = TRUE)\n  \n  table_aeroports &lt;- table_aeroports %&gt;%\n    fmt_markdown(columns = \"name_clean\")\n  \n  table_aeroports &lt;- table_aeroports %&gt;%\n    cols_label(\n      name_clean = md(\"**Aéroport**\"),\n      paxdep = md(\"**Départs**\"),\n      paxarr = md(\"**Arrivée**\"),\n      paxtra = md(\"**Transit**\")\n    ) %&gt;%\n    tab_header(\n      title = md(\"**Statistiques de fréquentation**\"),\n      subtitle = md(\"Classement des aéroports\")\n    ) %&gt;%\n    tab_style(\n      style = cell_fill(color = \"powderblue\"),\n      locations = cells_title()\n    ) %&gt;%\n    tab_source_note(source_note = md(\"_Source: DGAC, à partir des données sur data.gouv.fr_\"))\n  \n  table_aeroports &lt;- table_aeroports %&gt;%\n    opt_interactive()\n  \n  return(table_aeroports)\n\n}\n\n\n\n\nCode de main.R\n\n\n\nmain.R\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(plotly)\nlibrary(gt)\nlibrary(leaflet)\n\nsource(\"R/import_data.R\")\nsource(\"R/create_data_list.R\")\nsource(\"R/clean_dataframe.R\")\nsource(\"R/divers_functions.R\")\nsource(\"R/tables.R\")\nsource(\"R/figures.R\")\n\nYEARS_LIST  &lt;- as.character(2018:2022)\nMONTHS_LIST &lt;- c(paste0(\"0\", 1:9), 10:12)\nyear &lt;- YEARS_LIST[1]\nmonth &lt;- MONTHS_LIST[1]\n\n\n# Load data ----------------------------------\nurls &lt;- create_data_list(\"./sources.yml\")\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\n\nliste_aeroports &lt;- unique(pax_apt_all$apt)\ndefault_airport &lt;- liste_aeroports[1]\n\n# OBJETS NECESSAIRES A L'APPLICATION ------------------------\n\ntrafic_aeroports &lt;- pax_apt_all %&gt;%\n  mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr) %&gt;%\n  filter(apt %in% default_airport) %&gt;%\n  mutate(\n    date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n  )\n\nstats_aeroports &lt;- summary_stat_airport(\n  create_data_from_input(pax_apt_all, year, month)\n)\nstats_liaisons  &lt;- summary_stat_liaisons(\n  create_data_from_input(pax_lsn_all, year, month)\n)\n\n\n# VALORISATIONS ----------------------------------------------\n\nfigure_plotly &lt;- plot_airport_line(trafic_aeroports,default_airport)\n\ntable_airports &lt;- create_table_airports(stats_aeroports)"
  },
  {
    "objectID": "index.html#carte-des-aéroports",
    "href": "index.html#carte-des-aéroports",
    "title": "Un tableau de bord du trafic aérien avec  ou ",
    "section": "3.3 Carte des aéroports",
    "text": "3.3 Carte des aéroports\nLa dernière valorisation que nous allons intégrer est une carte interactive du trafic de nos aéroports. Cette carte va être assez basique. Si vous désirez mettre en oeuvre des visualisations plus complexes, vous pouvez tout à fait le faire.\nPour cet exercice, nous allons fixer une date pour prototyper notre code. Cela nous facilitera la transformation ultérieure en fonction.\n\nmonths &lt;- 1\nyears &lt;- 2019\n\nVoici également une palette de couleurs qui sera utile à la fin de l’exercice.\n\npalette &lt;- c(\"green\", \"blue\", \"red\")\n\n\n\n\n\n\n\n Exercice 5: carte aérienne du trafic aéroportuaire\n\n\n\n\n\n\nCréer un dataframe trafic_date en ne conservant que les observations de pax_apt_all égales à un certain mois et année (vous pouvez vous inspirer d’un filter fait précédemment). Utiliser celui-ci en faisant une jointure avec airports_location par le biais des variables, respectivement, Code.OACI et apt. Nommer ce dataframe trafic_aeroports\nA partir de l’exemple de démarrage de leaflet, créer une carte interactive qui affiche, lorsqu’on clique sur l’un des marqueurs, le nom de l’aéroport et sa fréquentation.\nCréer une variable nommée volume qui classe chaque observation dans son tercile et transforme la valeur en couleur à partir de palette.\n\nA partir du code suivant et de la fonction addAwesomeMarkers, reproduire une carte similaire à celle présentée plus bas.\n\nicons &lt;- awesomeIcons(\n  icon = 'plane',\n  iconColor = 'black',\n  library = 'fa',\n  markerColor = trafic_aeroports$color\n)\n\n\n\n\n\n\nSubtilité par rapport à l’exemple de la documentation\n\n\n\n\n\nPar rapport à l’exemple dans la documentation, il faut légèrement modifier le code de sorte à faire icon=icons[] et non icon = icons.\n\n\n\n\n\n\n\n\nQuestion 1\ntrafic_date &lt;- pax_apt_all %&gt;%\n  mutate(\n    date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n  ) %&gt;%\n  filter(mois %in% months, an %in% years)\ntrafic_aeroports &lt;- airports_location %&gt;%\n  inner_join(trafic_date, by = c(\"Code.OACI\" = \"apt\"))\n\n\n\n\nQuestion 2\nlibrary(leaflet)\n  \nleaflet(trafic_aeroports) %&gt;% addTiles() %&gt;%\n  addMarkers(popup = ~paste0(Nom, \": \", trafic)) \n\n\n\n\nQuestion 3\ntrafic_aeroports &lt;- trafic_aeroports %&gt;%\n  mutate(\n    volume = ntile(trafic, 3)\n) %&gt;%\n  mutate(\n    color = palette[volume]\n  )\n\n\n\n\nQuestion 3\nicons &lt;- awesomeIcons(\n  icon = 'plane',\n  iconColor = 'black',\n  library = 'fa',\n  markerColor = trafic_aeroports$color\n)\n\n\ncarte_interactive &lt;- leaflet(trafic_aeroports) %&gt;% addTiles() %&gt;%\n  addAwesomeMarkers(\n  icon=icons[],\n  label=~paste0(Nom, \"\", \" (\",Code.OACI, \") : \", trafic, \" voyageurs\")\n)\ncarte_interactive\n\n\n\n\n\n\nComme précédemment, nous proposons de transformer la production de cette carte en fonction, cela nous permettra d’avoir une application légère. Là encore c’est un exercice optionnel mais intéressant à faire pour découvrir la logique de la programmation fonctionnelle.\n\n\n\n\n\n\n Exercice 5b (optionnel): une fonction pour notre carte\n\n\n\n\n\n\nCréer une fonction map_leaflet_airport avec les arguments df, airports_location et selected_date produisant la carte. Insérer celle-ci dans le script R/figures.R\nMettre à jour main.R pour utiliser cette fonction dans votre chaine. N’oubliez pas de définir selected_date dans votre script.\n\n\n\n\n\n\nCode de R/figures.R à reprendre\n\n\n\nR/figures.R (fin du fichier)\n\n\nmap_leaflet_airport &lt;- function(df, airports_location, months, years){\n  \n  palette &lt;- c(\"green\", \"blue\", \"red\")\n\n  trafic_date &lt;- df %&gt;%\n    mutate(\n      date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n    ) %&gt;%\n    filter(mois %in% months, an %in% years)\n  trafic_aeroports &lt;- airports_location %&gt;%\n    inner_join(trafic_date, by = c(\"Code.OACI\" = \"apt\"))\n  \n  \n  trafic_aeroports &lt;- trafic_aeroports %&gt;%\n    mutate(\n      volume = ntile(trafic, 3)\n    ) %&gt;%\n    mutate(\n      color = palette[volume]\n    )  \n  \n  icons &lt;- awesomeIcons(\n    icon = 'plane',\n    iconColor = 'black',\n    library = 'fa',\n    markerColor = trafic_aeroports$color\n  )\n  \n  carte_interactive &lt;- leaflet(trafic_aeroports) %&gt;% addTiles() %&gt;%\n    addAwesomeMarkers(\n      icon=icons[],\n      label=~paste0(Nom, \"\", \" (\",Code.OACI, \") : \", trafic, \" voyageurs\")\n    )\n  \n  return(carte_interactive)\n}\n\n\n\n\nCode de intermediates/exo5.R à reprendre\n\n\n\nmain.R\n\nmonth &lt;- MONTHS_LIST[1]\n\n\n# Load data ----------------------------------\nurls &lt;- create_data_list(\"./sources.yml\")\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\n\nliste_aeroports &lt;- unique(pax_apt_all$apt)\ndefault_airport &lt;- liste_aeroports[1]\n\n\n# OBJETS NECESSAIRES A L'APPLICATION ------------------------\n\ntrafic_aeroports &lt;- pax_apt_all %&gt;%\n  mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr) %&gt;%\n  filter(apt %in% default_airport) %&gt;%\n  mutate(\n    date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n  )\n\nstats_aeroports &lt;- summary_stat_airport(\n  create_data_from_input(pax_apt_all, year, month)\n)\nstats_liaisons  &lt;- summary_stat_liaisons(\n  create_data_from_input(pax_lsn_all, year, month)\n)\n\n\n# VALORISATIONS ----------------------------------------------\n\nfigure_plotly &lt;- plot_airport_line(trafic_aeroports,default_airport)\n\ntable_airports &lt;- create_table_airports(stats_aeroports)\n\ncarte_interactive &lt;- map_leaflet_airport(\n  pax_apt_all, airports_location,\n  month, year\n)\n\n\nAppli5 Préparer un premier shiny sans plotly & leaflet\nAppli6 Ajouter à l’UI le plotly & leaflet\nAppli7 Contrôle de l’environnement avec renv"
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Un tableau de bord du trafic aérien avec  ou ",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nCes fichiers ne sont pas générés manuellement. Ce sont des outils adaptés (renv pour R, pip pour Python) qui font ce travail de versionnage de l’environnement.↩︎\nSi vous êtes peu familier avec ce type de fichiers, vous pouvez consulter la fiche utilitR sur le sujet↩︎\nSi vous êtes peu familier avec les données géographiques, vous pouvez retenir l’idée qu’il s’agit de données traditionnelles auxquelles s’ajoute une dimension spatiale. Cette dernière vise à localiser les données sur la terre. La localisation se fait dans un espace à deux dimensions (espace cartésien) alors que notre planète est une sphère en trois dimensions. Le principe d’un système de projection est de faire ce passage en deux dimensions des positions. Le plus connu est le système GPS, qui est un héritier lointain de la représentation du monde par Mercator. Ce système est connu sous le nom de WGS 84 et porte le code EPSG 4326. L’autre système à retenir est le Lambert 93 (code EPSG 2154) qui est la projection légale en France (celle-ci, a contrario du Mercator, ne déforme pas la France sur une carte). Pour en savoir plus sur les systèmes de représentation, les avantages et inconvénients de chacun, il existe de nombreuses ressources en ligne. Des éléments introductifs, et des démonstrations interactives, en lien avec la librairie Geopandas de Python sont disponibles ici.↩︎\nVous perdrez la mise en forme du header du tableau qui n’est pas conciliable avec l’interactivité.↩︎"
  }
]